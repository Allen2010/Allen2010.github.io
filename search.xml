<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Segment Tree 线段树笔记</title>
      <link href="/2025/03/22/Segment%20Tree/"/>
      <url>/2025/03/22/Segment%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><blockquote><p>线段树常用于解决区间修改查询问题，包括但不限于最大值、最小值和求和。线段树最大的难点，就是你不知道它将用来解决怎样的问题。</p></blockquote><!--more--><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线段树就是一棵普普通通的树，它的大部分节点都有两个子节点，但并不是一棵满二叉树，也不是完全二叉树。这一点你在学习后面的文章后就会明白了。<br>线段树上每一个节点都代表着一段区间，而每个子结点代表的区间长度都是其父节点的一半。若长度是奇数则会有些许偏差。而节点的值则是这个区间的需求。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>线段树可以解决大部分的区间问题，只要你能想清楚怎么分治，基本上就是线段树没得跑。哪怕这个区间的需求是连续的。<br>通常来说，线段树的操作分为以下几种：</p><ul><li><strong>建树</strong>：输入数组并建立对应需求的线段树</li><li><strong>单点修改</strong>：将 $x$ 位置的元素改成 $v$</li><li><strong>区间修改</strong>：将 $l$ 到 $r$ 位置的所用元素改成或增加 $v$</li><li><strong>区间查询</strong>：查询 $l$ 到 $r$ 区间内的最大/最小/和/其他需求</li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>线段树用数组实现。注意数组大小要开到 $4 \times n$。左右子树的编号分别是 $i \times 2$ 和 $i \times 2 + 1$。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">lc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">ll <span class="title">rc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure></div></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>从根节点开始，不断的分割区间直到该区间只剩单个数，然后开始向上汇总。传入两个变量 <code>l</code> 和 <code>r</code>， 表示当前节点表示的线段。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">sum[p] = sum[<span class="built_in">lc</span>(p)] + sum[<span class="built_in">rc</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum[p] = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid);</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushUp</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>从根节点开始，如果当前的线段不被查询的区间完全包含就一直分两段尝试，直到它被完全包含了，返回该线段的值然后继续递归其他的。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushDown</span>(p, l, r);</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">ans += <span class="built_in">Query</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(qr &gt; mid)&#123;</span><br><span class="line">ans += <span class="built_in">Query</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>如果每次修改都从上到下全改一遍，复杂度得 $\mathcal{O}(n)$ ，太浪费时间了，完全体现不出线段树的优势所在。因此引入懒标记（Lazy Tag）。和查询一样，当线段被区间完全覆盖时，对应的节点自己更新，但它的孩子们不更新。这时给他安上一个懒标记，表示它的子节点需要更新的大小。当区间没有完全覆盖，需要拆分的时候，将当前变量的标记拆掉，传给子节点，这样才不会错算。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr, ll d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">sum[p] += d * (r - l + <span class="number">1</span>);</span><br><span class="line">tag[p] += d;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushDown</span>(p, l, r);</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line"><span class="built_in">Update</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(qr &gt; mid)&#123;</span><br><span class="line"><span class="built_in">Update</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushUp</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3>  <div class="note p-4 mb-4 rounded-small [blue] [例题：Luogu P3372]">    <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll segt[<span class="number">4</span> * MAXN], tag[<span class="number">4</span> * MAXN], a[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">lc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">ll <span class="title">rc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">    segt[p] = <span class="built_in">min</span>(segt[<span class="built_in">lc</span>(p)], segt[<span class="built_in">rc</span>(p)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        segt[p] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveTag</span><span class="params">(ll p, ll k)</span></span>&#123;</span><br><span class="line">    tag[p] += k;</span><br><span class="line">    segt[p] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">moveTag</span>(<span class="built_in">lc</span>(p), tag[p]);</span><br><span class="line">    <span class="built_in">moveTag</span>(<span class="built_in">rc</span>(p), tag[p]);</span><br><span class="line">    tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">        <span class="built_in">moveTag</span>(p, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushDown</span>(p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid)<span class="built_in">Update</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)<span class="built_in">Update</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="built_in">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> segt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushDown</span>(p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid)ans = <span class="built_in">min</span>(ans, <span class="built_in">Query</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr));</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)ans = <span class="built_in">min</span>(ans, <span class="built_in">Query</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        ll opt, l, r;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>  </div><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><h3 id="区间和并线段树"><a href="#区间和并线段树" class="headerlink" title="区间和并线段树"></a>区间和并线段树</h3><p>在遇到有区间连续的需求时，我们发现传统线段树并不适用，因为分段时无法控制答案的范围，在向上整理回父节点时可能会遇到答案的中间部分没有连接但却错误转移的情况。<br>我们可以定义额外的变量存于线段树的数组，分别表示了以区间最左边和最右边起始的答案，这样就只需要思考如何 <code>pushUp</code> 转移了。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3>  <div class="note p-4 mb-4 rounded-small [blue] [例题：区间最大连续子序列和]">    <p>输入一个长度为 $n$ 的数组 $a$，数组的元素均为整数且满足 $-4000 \leq a_i \leq 4000$。对该数组可以发出 $m$ 条指令。指令共有 $2$ 种：</p><ul><li><code>1 x v</code>，该指令将 $a_x$ 的值修改为 $v$</li><li><code>2 l r</code>，该指令查询区间 $l$ 到 $r$ 的最大连续子序列和，即区间所有可能的连续子序列中求和的最大值</li></ul><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MAXN = <span class="number">400005</span>, fINF = LONG_LONG_MIN;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>, lans = fINF, rans = fINF, ans = fINF;</span><br><span class="line">&#125;segt[<span class="number">4</span> * MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">lc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">ll <span class="title">rc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">    segt[p].sum = segt[<span class="built_in">lc</span>(p)].sum + segt[<span class="built_in">rc</span>(p)].sum;</span><br><span class="line">    segt[p].lans = <span class="built_in">max</span>(&#123;segt[<span class="built_in">lc</span>(p)].sum + segt[<span class="built_in">rc</span>(p)].lans, segt[<span class="built_in">lc</span>(p)].lans&#125;);</span><br><span class="line">    segt[p].rans = <span class="built_in">max</span>(&#123;segt[<span class="built_in">rc</span>(p)].sum + segt[<span class="built_in">lc</span>(p)].rans, segt[<span class="built_in">rc</span>(p)].rans&#125;);</span><br><span class="line">    segt[p].ans = <span class="built_in">max</span>(&#123;segt[<span class="built_in">lc</span>(p)].rans + segt[<span class="built_in">rc</span>(p)].lans, segt[<span class="built_in">lc</span>(p)].ans, segt[<span class="built_in">rc</span>(p)].ans&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        segt[p].ans = segt[p].lans = segt[p].rans = segt[p].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll p, ll l, ll r, ll x, ll v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        segt[p].sum = segt[p].ans = segt[p].lans = segt[p].rans = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)<span class="built_in">Update</span>(<span class="built_in">lc</span>(p), l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; mid)<span class="built_in">Update</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">Query</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> segt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid &amp;&amp; qr &gt; mid)&#123;</span><br><span class="line">        Node ans, qla = <span class="built_in">Query</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr), qra = <span class="built_in">Query</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">        ans.sum = qla.sum + qra.sum;</span><br><span class="line">        ans.ans = <span class="built_in">max</span>(&#123;ans.ans, qla.ans, qra.ans, qla.rans + qra.lans&#125;);</span><br><span class="line">        ans.lans = <span class="built_in">max</span>(&#123;ans.lans, qla.lans, qla.sum + qra.lans&#125;);</span><br><span class="line">        ans.rans = <span class="built_in">max</span>(&#123;ans.rans, qra.rans, qra.sum + qla.rans&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Query</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Query</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        ll opt, l, r;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r).ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>  </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>极为常用，需要会用、会推、会写且达到熟练的地步。复杂度 $\mathcal{O(log_2 n)}$，已经很快了。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> data structure </tag>
            
            <tag> divide &amp; conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCA 最近共同祖先算法笔记</title>
      <link href="/2025/03/02/Lowest%20Common%20Ancestor/"/>
      <url>/2025/03/02/Lowest%20Common%20Ancestor/</url>
      
        <content type="html"><![CDATA[<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><blockquote><p>恐龙，是指三角龙、现代鸟类和梁龙的最近共同祖先 (LCA) 及其所有后代。  ——百度百科</p></blockquote><!--more--><p>假设有一棵树，上面有两个节点，求两个节点最近的共同祖先节点。也可以理解为包含这两个节点的子树是从什么时候分开的。</p><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><blockquote><p>一生二，二生四，四生万物。  ——泥土笨笨</p></blockquote><p>采用倍增的思想，将查询最近共同祖先问题分成若干部：</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>预处理一个数组 <code>anc[i][j]</code> 表示 $i$ 节点的 $2^j$ 号祖先的编号。其中有 <code>anc[i][j] = anc[anc[i][j - 1]][j - 1];</code> 意思是 $i$ 的 $2^j$ 祖先就是 $i$ 的 $2^{j-1}$ 的祖先的 $2^{j-1}$ 祖先。通过这个式子就可以转移了。<br>转移过程中同时预处理 $dep[i]$ 数组表示深度，后面会用到。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u, ll father)</span></span>&#123; <span class="comment">//该节点和它的父亲节点</span></span><br><span class="line">dep[u] = dep[father] + <span class="number">1</span>; <span class="comment">//预处理深度</span></span><br><span class="line">anc[u][<span class="number">0</span>] = father; <span class="comment">//i 的 第一个祖先，即父亲。</span></span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[u]; i ++)&#123;</span><br><span class="line">anc[u][i] = anc[anc[u][i - <span class="number">1</span>]][i - <span class="number">1</span>]; <span class="comment">//转移，由于是从小到大枚举的j，所以当前的anc转移一定是正确的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = head[u]; i; i = pool[i].next)&#123; <span class="comment">//往下递归</span></span><br><span class="line"><span class="keyword">if</span>(pool[i].v != father)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(pool[i].v, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="调整深度"><a href="#调整深度" class="headerlink" title="调整深度"></a>调整深度</h2><p>追平深度。顾名思义，通过不断调整深度让需要查询的两个节点深度相等。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dep[x] &lt; dep[y])&#123;</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(dep[x] &gt; dep[y])&#123;</span><br><span class="line">x = anc[x][lg[dep[x] - dep[y]] - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="跳跃结算"><a href="#跳跃结算" class="headerlink" title="跳跃结算"></a>跳跃结算</h2><p>一起往上调，跳的步数从 $2^{dep_x}$ 步开始不断尝试，如果调完了发现重合，就放弃，然后尝试少跳一点，以此类推。直到最后到达了最接近共同祖先的位置，即共同祖先的孩子节点。为什么重合要放弃？因为谁也没办法保证当前的重合点是最近的，要不断尝试下调就太麻烦了。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x == y)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(ll i = lg[dep[x]]; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i];</span><br><span class="line">y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br></pre></td></tr></table></figure></div></p><h1 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h1><p>例题：<a class="link"   href="https://www.luogu.com.cn/problem/P3379" >洛谷 P3379【模板】最近公共祖先（LCA）<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MAXN = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">ll v, next;</span><br><span class="line">&#125;pool[<span class="number">2</span> * MAXN];</span><br><span class="line">ll anc[MAXN][<span class="number">25</span>], dep[MAXN], head[MAXN], nn, lg[MAXN];</span><br><span class="line">ll n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(ll u, ll v)</span></span>&#123;</span><br><span class="line">pool[++nn].v = v;</span><br><span class="line">pool[nn].next = head[u];</span><br><span class="line">head[u] = nn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u, ll father)</span></span>&#123;</span><br><span class="line">dep[u] = dep[father] + <span class="number">1</span>;</span><br><span class="line">anc[u][<span class="number">0</span>] = father;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[u]; i ++)&#123;</span><br><span class="line">anc[u][i] = anc[anc[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = head[u]; i; i = pool[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(pool[i].v != father)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(pool[i].v, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lca</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &lt; dep[y])&#123;</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(dep[x] &gt; dep[y])&#123;</span><br><span class="line">x = anc[x][lg[dep[x] - dep[y]] - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == y)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(ll i = lg[dep[x]]; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line"><span class="keyword">if</span>(anc[x][i] != anc[y][i])&#123;</span><br><span class="line">x = anc[x][i];</span><br><span class="line">y = anc[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">ll x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">addEdge</span>(x, y);</span><br><span class="line"><span class="built_in">addEdge</span>(y, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">lg[i] = lg[i - <span class="number">1</span>] + ((<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>]) == i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">ll x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">lca</span>(x, y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> binary lifting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sparse Table ST表笔记</title>
      <link href="/2025/02/22/Sparse%20Table/"/>
      <url>/2025/02/22/Sparse%20Table/</url>
      
        <content type="html"><![CDATA[<h1 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h1><blockquote><p>RMQ 是 Range Maximum/Minimum Query 的缩写，表示可重复贡献的区间最大/最小值。</p></blockquote><!--more--><p>显而易见的，可以用线段树实现。但是由于该问题不涉及修改操作，且线段树太长了不好写，十分浪费时间。</p><p>这是就需要用到好理解又好写的ST表了。</p><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><blockquote><p>ST表(Sparse Table)是用于解决<strong>可重复贡献问题</strong>的数据结构。</p></blockquote><p><strong>倍增思想</strong>：我们考虑将 $st_{i,j}$ 定义为 起点为 $i$, 到 $i + 2^j - 1$ 位置的所有元素的最大值。例如 $st_{i,1}$ 表示 $i$ 和 $i + 1$ 中的最大值。</p><h2 id="转移过程"><a href="#转移过程" class="headerlink" title="转移过程"></a>转移过程</h2><p>把当前区间拆成两个大小相等的区间，用动态规划求出答案。</p><script type="math/tex; mode=display">st_{i,j} = max(st_{i,j - 1},st_{i + 2^{j-1},j - 1})</script><p>这样就可以保证该区间内所有的元素都被转移了。预处理就是将 $st_{i,0}$ 表示第 $i$ 个元素的最大值，即本身。</p><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><p>查询过程也一样，分成两个区间，这里我用的是  $st_{i,k}$ 和 $st_{r-2^k+1,k}$，因为这样刚好有一部分重叠，可以保证答案转移的正确性，然后分别求最大值最后在汇总一下。</p><script type="math/tex; mode=display">max(st_{l,k}, st_{r - 2^k + 1,k})</script><p>其中的 <code>k = log[r - l + 1]</code>，用于分隔两个区间。至于怎么求 $\log$，这里我用的是传统求 <code>lg[i] + 1</code> 的写法，见下方代码。</p><h1 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h1><p><strong>例题：洛谷 <a class="link"   href="https://www.luogu.com.cn/problem/P3865" >P3865【模板】ST 表 &amp;&amp; RMQ 问题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong><br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll st[MAXN][<span class="number">25</span>], lg[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll l, ll r)</span></span>&#123;</span><br><span class="line">ll k = lg[r - l + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>); </span><br><span class="line">ll n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">cin &gt;&gt; st[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">lg[i] = lg[i - <span class="number">1</span>] + ((<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>]) == i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++)&#123;</span><br><span class="line">st[i][j] = <span class="built_in">max</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m --)&#123;</span><br><span class="line">ll l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Query</span>(l, r) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h1 id="更多思考"><a href="#更多思考" class="headerlink" title="更多思考"></a>更多思考</h1><blockquote><p>为什么 ST表 似乎很少被用于区间求和之类的问题？</p></blockquote><p>这个问题看起来很傻，却很有用。大概有如下两个原因：</p><ul><li>可以用前缀和，更好写还不容易错</li><li>ST表如果想要O(1)查询，需要满足所求的问题区间能够重复覆盖。因为查询是两边重叠算的啊</li></ul><p>显然，对于第二点，区间求和并不满足条件（如果重复覆盖就会有许多值被加了多次）。那么可不可以进行二进制拆分呢？答案显然是可以的。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> data structure </tag>
            
            <tag> binary lifting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Floyd 全源最短路径算法笔记</title>
      <link href="/2024/10/13/Floyd%20Path/"/>
      <url>/2024/10/13/Floyd%20Path/</url>
      
        <content type="html"><![CDATA[<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><blockquote><p>三个破变量，一共就十行。编程十分钟，运行一晚上。</p></blockquote><!--more--><p>很多人认为 Floyd 就是简单的动态规划，甚至有人直接把它当模板背了下来，导致不会变通而 WA 了 <a class="link"   href="https://www.luogu.com.cn/problem/P1119" >P1119<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。然而其实大多数初学者<del>包括我</del>一开始都理解错了它，包括原理。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>定义 $dis_{i,j}^k$ 表示只包含前 $k$ 个节点时 $i$ 到 $j$ 的最短路。而加不加入这个 $k$ 号元素前后有什么区别呢？无非就是某两个点的最短路通过 $k$ 号点松弛出了更有的最短路嘛。于是就有了经典代码：<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ll k = <span class="number">1</span>; k &lt;= n; k ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>那么如何初始化呢？如果 $i$ 到 $j$ 有路，就初始化为边长。否则初始化为最大值。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j)dis[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(gph[i][j])dis[i][j] = gph[i][j];</span><br><span class="line"><span class="keyword">else</span> dis[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>这就完了吗？这值得写博客吗？当然不值。<del>虽然我本来就是给自己写来复习的</del></p><h1 id="Floyd应用"><a href="#Floyd应用" class="headerlink" title="Floyd应用"></a>Floyd应用</h1><h2 id="Floyd解决传递闭包问题"><a href="#Floyd解决传递闭包问题" class="headerlink" title="Floyd解决传递闭包问题"></a>Floyd解决传递闭包问题</h2><p><a href="www.luogu.com.cn/problem/B3611">题目传送门</a></p><blockquote><p>在有向图中，定义 $d_{i,j}$ 如果是 1，则表示 $i$ 能到达 $j$，否则反之。</p></blockquote><p>这该如何解决呢？转换一下定义。<br>定义 $d_{i,j}^k$ 表示只有前 $k$ 个点时 $i$ 能否到达 $j$。同理，加入了一个元素 $k$ 之后无非就是有一组 $i$ 能通过它到达 $j$ 了。</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(graph[i][j])d[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> d[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll k = <span class="number">1</span>; k &lt;= n; k ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">d[i][j] = d[i][j] || (d[i][k] &amp;&amp; d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">cout &lt;&lt; d[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h2 id="Floyd求最小环"><a href="#Floyd求最小环" class="headerlink" title="Floyd求最小环"></a>Floyd求最小环</h2><p>依旧是改定义：$d_{i,j}^k$ 为前 $k$ 个节点中可以确定的最小环的大小。则匹配最短路，可以在算最短路之后算环了，可以理解为以 $k$ 为一个顶点，由 $k$ 可以到达的 $i$ 和 $j$ 以及 $dis_{i,j}$ 也就是最短路构成的环。然后枚举已经算出最短路的 $i,j$ 即可。<br>例题就是 <a class="link"   href="https://www.luogu.com.cn/problem/P2738" >P2738 篱笆回路<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。这题输入特别逆天，所以给了完整代码。<br><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MAXN = <span class="number">305</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">ll u, v, w;</span><br><span class="line"><span class="type">bool</span> lside[MAXN], rside[MAXN];</span><br><span class="line">&#125;edge[MAXN]; </span><br><span class="line"></span><br><span class="line">ll adj[MAXN][MAXN], father[MAXN], m, n, idx[MAXN], dis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(father[x] == x)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">father[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll ans = INF;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!dis[i][j])dis[i][j] = INF;</span><br><span class="line"><span class="keyword">if</span>(!adj[i][j])adj[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">adj[i][i] = dis[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll k = <span class="number">1</span>; k &lt;= n; k ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= k - <span class="number">1</span>; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = i + <span class="number">1</span>; j &lt;= k - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(ans, adj[i][k] + adj[k][j] + dis[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">ll s, len, numl, numr, id;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; len &gt;&gt; numl &gt;&gt; numr;</span><br><span class="line">edge[s].u = s * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">edge[s].v = s * <span class="number">2</span>;</span><br><span class="line">edge[s].w = len;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= numl; j ++)&#123;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line">edge[s].lside[id] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= numr; j ++)&#123;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line">edge[s].rside[id] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">250</span>; i ++)&#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(edge[i].lside[j] &amp;&amp; edge[j].lside[i])&#123;</span><br><span class="line"><span class="built_in">merge</span>(edge[i].u, edge[j].u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(edge[i].lside[j] &amp;&amp; edge[j].rside[i])&#123;</span><br><span class="line"><span class="built_in">merge</span>(edge[i].u, edge[j].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(edge[i].rside[j] &amp;&amp; edge[j].lside[i])&#123;</span><br><span class="line"><span class="built_in">merge</span>(edge[i].v, edge[j].u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(edge[i].rside[j] &amp;&amp; edge[j].rside[i])&#123;</span><br><span class="line"><span class="built_in">merge</span>(edge[i].v, edge[j].v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(father[i] == i)&#123;</span><br><span class="line">idx[i] = ++n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">edge[i].u = idx[<span class="built_in">find</span>(edge[i].u)];</span><br><span class="line">edge[i].v = idx[<span class="built_in">find</span>(edge[i].v)];</span><br><span class="line">adj[edge[i].u][edge[i].v] = edge[i].w;</span><br><span class="line">adj[edge[i].v][edge[i].u] = edge[i].w;</span><br><span class="line">dis[edge[i].u][edge[i].v] = edge[i].w;</span><br><span class="line">dis[edge[i].v][edge[i].u] = edge[i].w;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Floyd</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Floyd 算法似乎从方方面面看都很平庸：时间复杂度高达 $\mathcal{O}(n^3)$，需要空间复杂度耗费较大的邻接矩阵存图，甚至连模板的使用环境都比较小。<br>然而 Floyd 算法具有较高的灵活性、可读性和可写性。一旦深刻理解了它的原理，就可以加以变通，解决许许多多看似复杂的算法。以上就是例子，希望大家不要想我最初一样，只背了模板，没有思考含义。</p><blockquote><p>Floyd 算法之所以被发明出来，并不是因为他比 Dijkstra 更快，比 SPFA 更好理解，而是因为，<del>他善</del>啊……</p></blockquote><hr><p>推荐例题：洛谷 P1119 灾后重建，P1841 重要的城市</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> shortest path </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
