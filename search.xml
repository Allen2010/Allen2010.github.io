<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Segment Tree 线段树笔记</title>
    <url>/2025/01/27/Segment%20Tree/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><blockquote>
<p>线段树是一种能够处理区间修改和区间查询的数据结构。</p>
</blockquote>
<p>顾名思义，线段树就是一种存储着线段数据的树形结构。它的每个节点都表示一个线段区间，每个节点的孩子节点存储的就是该区间的左半段和右半段。每个线段区间都存储着一个值，一般是区间和，也有可能是区间最大&#x2F;最小值。</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>线段树使用数组实现，根节点编号为 $1$ 表示区间 $1$ 到 $n$，左子节点是 $i \times 2$，右子节点是 $i \times 2 + 1$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">lc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">ll <span class="title">rc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>从根节点开始，不断的分割区间直到该区间只剩单个数，然后开始向上汇总。传入两个变量 <code>l</code> 和 <code>r</code>， 表示当前节点表示的线段。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">	sum[p] = sum[<span class="built_in">lc</span>(p)] + sum[<span class="built_in">rc</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		sum[p] = a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid);</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="built_in">pushUp</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>从根节点开始，如果当前的线段不被查询的区间完全包含就一直分两段尝试，直到它被完全包含了，返回该线段的值然后继续递归其他的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">		<span class="keyword">return</span> sum[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushDown</span>(p, l, r);</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">		ans += <span class="built_in">Query</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(qr &gt; mid)&#123;</span><br><span class="line">		ans += <span class="built_in">Query</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h2><p>如果每次修改都从上到下全改一遍，复杂度得 $\mathcal{O}(n)$ ，太浪费时间了，完全体现不出线段树的优势所在。因此引入懒标记（Lazy Tag）。和查询一样，当线段被区间完全覆盖时，对应的节点自己更新，但它的孩子们不更新。这时给他安上一个懒标记，表示它的子节点需要更新的大小。当区间没有完全覆盖，需要拆分的时候，将当前变量的标记拆掉，传给子节点，这样才不会错算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr, ll d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">		sum[p] += d * (r - l + <span class="number">1</span>);</span><br><span class="line">		tag[p] += d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushDown</span>(p, l, r);</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">		<span class="built_in">Update</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr, d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(qr &gt; mid)&#123;</span><br><span class="line">		<span class="built_in">Update</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushUp</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度估算"><a href="#复杂度估算" class="headerlink" title="复杂度估算"></a>复杂度估算</h2><p>由于线段树原理是每个区间分两段，再将两端区间分别分段以此类推，又有 $n$ 个元素，因此线段树的高度是 $\log n$ 的。而区间修改和查询最坏都要遍历一遍每一层，因此修改和查询的复杂度都是 $\mathcal{O}\log n$ 的，足以应付大部分题目。</p>
<h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><p>题目：<a href="https://www.luogu.com.cn/problem/P3372">洛谷 P3372【模板】线段树 1</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll sum[<span class="number">4</span> * MAXN], a[MAXN], tag[<span class="number">4</span> * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">ll <span class="title">rc</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">	sum[p] = sum[<span class="built_in">lc</span>(p)] + sum[<span class="built_in">rc</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		sum[p] = a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid);</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="built_in">pushUp</span>(p); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveTag</span><span class="params">(ll p, ll l, ll r, ll t)</span></span>&#123;</span><br><span class="line">	sum[p] += t * (r - l + <span class="number">1</span>);</span><br><span class="line">	tag[p] += t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(ll p, ll l, ll r)</span></span>&#123;</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">moveTag</span>(<span class="built_in">lc</span>(p), l, mid, tag[p]);</span><br><span class="line">	<span class="built_in">moveTag</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">	tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr, ll d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">		sum[p] += d * (r - l + <span class="number">1</span>);</span><br><span class="line">		tag[p] += d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushDown</span>(p, l, r);</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">		<span class="built_in">Update</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr, d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(qr &gt; mid)&#123;</span><br><span class="line">		<span class="built_in">Update</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll p, ll l, ll r, ll ql, ll qr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">		<span class="keyword">return</span> sum[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushDown</span>(p, l, r);</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql &lt;= mid)&#123;</span><br><span class="line">		ans += <span class="built_in">Query</span>(<span class="built_in">lc</span>(p), l, mid, ql, qr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(qr &gt; mid)&#123;</span><br><span class="line">		ans += <span class="built_in">Query</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>); </span><br><span class="line">	ll n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">while</span>(m --)&#123;</span><br><span class="line">		ll o, x, y, k;</span><br><span class="line">		cin &gt;&gt; o;</span><br><span class="line">		<span class="keyword">if</span>(o == <span class="number">1</span>)&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			<span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Sparse Table ST表笔记</title>
    <url>/2025/01/27/Sparse%20Table/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote>
<p>RMQ 是 Range Maximum&#x2F;Minimum Query 的缩写，表示可重复贡献的区间最大&#x2F;最小值。</p>
</blockquote>
<p>显而易见的，可以用线段树实现。但是由于该问题不涉及修改操作，且线段树太长了不好写，十分浪费时间。</p>
<p>这是就需要用到好理解又好写的ST表了。</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><blockquote>
<p>ST表(Sparse Table)是用于解决<strong>可重复贡献问题</strong>的数据结构。</p>
</blockquote>
<p><strong>倍增思想</strong>：我们考虑将 $st_{i,j}$ 定义为 起点为 $i$, 到 $i + 2^j - 1$ 位置的所有元素的最大值。例如 $st_{i,1}$ 表示 $i$ 和 $i + 1$ 中的最大值。</p>
<h3 id="该如何处理转移过程？"><a href="#该如何处理转移过程？" class="headerlink" title="该如何处理转移过程？"></a>该如何处理转移过程？</h3><p>把当前区间拆成两个大小相等的区间，用动态规划求出答案。<br>$$st_{i,j} &#x3D; max(st_{i,j - 1},st_{i + 2^{j-1},j - 1})$$<br>这样就可以保证该区间内所有的元素都被转移了。预处理就是将 $st_{i,0}$ 表示第 $i$ 个元素的最大值，即本身。</p>
<h3 id="查询过程？"><a href="#查询过程？" class="headerlink" title="查询过程？"></a>查询过程？</h3><p>查询过程也一样，分成两个区间，这里我用的是  $st_{i,k}$ 和 $st_{r-2^k+1,k}$，因为这样刚好有一部分重叠，可以保证答案转移的正确性，然后分别求最大值最后在汇总一下。<br>$$max(st_{l,k}, st_{r - 2^k + 1,k})$$<br>其中的 <code>k = log[r - l + 1]</code>，用于分隔两个区间。至于怎么求 $\log$，这里我用的是传统求 <code>lg[i] + 1</code> 的写法，见下方代码。</p>
<h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><p><strong>例题：洛谷 <a href="https://www.luogu.com.cn/problem/P3865">P3865【模板】ST 表 &amp;&amp; RMQ 问题</a></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll st[MAXN][<span class="number">25</span>], lg[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll l, ll r)</span></span>&#123;</span><br><span class="line">	ll k = lg[r - l + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>); </span><br><span class="line">	ll n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; st[i][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		lg[i] = lg[i - <span class="number">1</span>] + ((<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>]) == i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++)&#123;</span><br><span class="line">			st[i][j] = <span class="built_in">max</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m --)&#123;</span><br><span class="line">		ll l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">Query</span>(l, r) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更多思考"><a href="#更多思考" class="headerlink" title="更多思考"></a>更多思考</h2><blockquote>
<p>为什么 ST表 似乎很少被用于区间求和之类的问题？</p>
</blockquote>
<p>这个问题看起来很傻，却很有用。大概有如下两个原因：</p>
<ul>
<li>可以用前缀和，更好写还不容易错</li>
<li>ST表如果想要O(1)查询，需要满足所求的问题区间能够重复覆盖。因为查询是两边重叠算的啊</li>
</ul>
<p>显然，对于第二点，区间求和并不满足条件（如果重复覆盖就会有许多值被加了多次）。那么可不可以进行二进制拆分呢？答案显然是可以的。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
</search>
