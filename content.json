{"meta":{"title":"Allen2010 Blog","subtitle":"Explore Here!","description":"BlackBasalt","author":"Allenyang","url":"https://allen2010.github.io","root":"/"},"pages":[{"title":"","date":"2025-01-27T10:19:59.884Z","updated":"2025-01-27T10:19:59.884Z","comments":true,"path":"about/index.html","permalink":"https://allen2010.github.io/about/index.html","excerpt":"","text":"个人资料 出生年份：2010年北京 爱好：编程、写小说片段 基本资料： 初二 Luogu OIer，没什么水平，爱好算法。喜欢诸如 The Lord of the Rings 和 A Song of Ice and Fire 之类的奇幻小说。喜欢写一些以 MC 和自然为主题的冒险小说片段。"},{"title":"文章分类","date":"2021-01-25T14:37:25.000Z","updated":"2025-03-16T00:12:10.637Z","comments":true,"path":"categories/index.html","permalink":"https://allen2010.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-25T14:54:58.000Z","updated":"2025-03-16T00:11:06.974Z","comments":true,"path":"tags/index.html","permalink":"https://allen2010.github.io/tags/index.html","excerpt":"","text":""},{"title":"FRIENDS","date":"2025-01-27T04:21:54.497Z","updated":"2025-01-27T04:21:54.497Z","comments":true,"path":"friends/index.html","permalink":"https://allen2010.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2025-02-26T13:36:12.282Z","updated":"2025-02-26T13:36:12.282Z","comments":true,"path":"css/custom.css","permalink":"https://allen2010.github.io/css/custom.css","excerpt":"","text":"@font-face { /* 为载入的字体取名字(随意) */ font-family: 'LXGWWenKai-Regular'; /* 字体文件地址(相对或者绝对路径都可以) */ src: url(fonts/TTF/LXGWWenKai-Regular.ttf); /* 定义加粗样式(加粗多少) */ font-weight: normal; /* 定义字体样式(斜体/非斜体) */ font-style: normal; /* 定义显示样式 */ font-display: block; }"}],"posts":[{"title":"LCA 最近共同祖先算法笔记","slug":"Lowest Common Ancestor","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-16T14:55:29.253Z","comments":true,"path":"2025/03/02/Lowest Common Ancestor/","permalink":"https://allen2010.github.io/2025/03/02/Lowest%20Common%20Ancestor/","excerpt":"摘要：对于一棵树上任意两个节点的最近共同祖先问题，能否用倍增法解决？ 算法描述 恐龙，是指三角龙、现代鸟类和梁龙的最近共同祖先 (LCA) 及其所有后代。 ——百度百科","text":"摘要：对于一棵树上任意两个节点的最近共同祖先问题，能否用倍增法解决？ 算法描述 恐龙，是指三角龙、现代鸟类和梁龙的最近共同祖先 (LCA) 及其所有后代。 ——百度百科 假设有一棵树，上面有两个节点，求两个节点最近的共同祖先节点。也可以理解为包含这两个节点的子树是从什么时候分开的。 算法思路 一生二，二生四，四生万物。 ——泥土笨笨 采用倍增的思想，将查询最近共同祖先问题分成若干部： 预处理预处理一个数组 anc[i][j] 表示 $i$ 节点的 $2^j$ 号祖先的编号。其中有 anc[i][j] = anc[anc[i][j - 1]][j - 1]; 意思是 $i$ 的 $2^j$ 祖先就是 $i$ 的 $2^{j-1}$ 的祖先的 $2^{j-1}$ 祖先。通过这个式子就可以转移了。转移过程中同时预处理 $dep[i]$ 数组表示深度，后面会用到。 123456789101112void dfs(ll u, ll father)&#123; //该节点和它的父亲节点 dep[u] = dep[father] + 1; //预处理深度 anc[u][0] = father; //i 的 第一个祖先，即父亲。 for(ll i = 1; (1 &lt;&lt; i) &lt;= dep[u]; i ++)&#123; anc[u][i] = anc[anc[u][i - 1]][i - 1]; //转移，由于是从小到大枚举的j，所以当前的anc转移一定是正确的 &#125; for(ll i = head[u]; i; i = pool[i].next)&#123; //往下递归 if(pool[i].v != father)&#123; dfs(pool[i].v, u); &#125; &#125;&#125; 调整深度追平深度。顾名思义，通过不断调整深度让需要查询的两个节点深度相等。 123456if(dep[x] &lt; dep[y])&#123; swap(x, y);&#125;while(dep[x] &gt; dep[y])&#123; x = anc[x][lg[dep[x] - dep[y]] - 1];&#125; 跳跃结算一起往上调，跳的步数从 $2^{dep_x}$ 步开始不断尝试，如果调完了发现重合，就放弃，然后尝试少跳一点，以此类推。直到最后到达了最接近共同祖先的位置，即共同祖先的孩子节点。为什么重合要放弃？因为谁也没办法保证当前的重合点是最近的，要不断尝试下调就太麻烦了。 12345678if(x == y)return x;for(ll i = lg[dep[x]]; i &gt;= 0; i --)&#123; if(anc[x][i] != anc[y][i])&#123; x = anc[x][i]; y = anc[y][i]; &#125;&#125;return anc[x][0]; 总代码例题：洛谷 P3379【模板】最近公共祖先（LCA） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const ll MAXN = 500005;struct Node&#123; ll v, next;&#125;pool[2 * MAXN];ll anc[MAXN][25], dep[MAXN], head[MAXN], nn, lg[MAXN];ll n, m, s;void addEdge(ll u, ll v)&#123; pool[++nn].v = v; pool[nn].next = head[u]; head[u] = nn;&#125;void dfs(ll u, ll father)&#123; dep[u] = dep[father] + 1; anc[u][0] = father; for(ll i = 1; (1 &lt;&lt; i) &lt;= dep[u]; i ++)&#123; anc[u][i] = anc[anc[u][i - 1]][i - 1]; &#125; for(ll i = head[u]; i; i = pool[i].next)&#123; if(pool[i].v != father)&#123; dfs(pool[i].v, u); &#125; &#125;&#125;ll lca(ll x, ll y)&#123; if(dep[x] &lt; dep[y])&#123; swap(x, y); &#125; while(dep[x] &gt; dep[y])&#123; x = anc[x][lg[dep[x] - dep[y]] - 1]; &#125; if(x == y)return x; for(ll i = lg[dep[x]]; i &gt;= 0; i --)&#123; if(anc[x][i] != anc[y][i])&#123; x = anc[x][i]; y = anc[y][i]; &#125; &#125; return anc[x][0];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for(ll i = 1; i &lt;= n - 1; i ++)&#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; addEdge(x, y); addEdge(y, x); &#125; for(ll i = 1; i &lt;= n; i ++)&#123; lg[i] = lg[i - 1] + ((1 &lt;&lt; lg[i - 1]) == i); &#125; dfs(s, 0); for(ll i = 1; i &lt;= m; i ++)&#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(x, y) &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"shortest path","slug":"shortest-path","permalink":"https://allen2010.github.io/tags/shortest-path/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"}]},{"title":"Sparse Table ST表笔记","slug":"Sparse Table","date":"2025-02-21T16:00:00.000Z","updated":"2025-03-16T14:55:13.484Z","comments":true,"path":"2025/02/22/Sparse Table/","permalink":"https://allen2010.github.io/2025/02/22/Sparse%20Table/","excerpt":"摘要：区间贡献问题的另一种更简单、更快捷的解决方案。 问题叙述 RMQ 是 Range Maximum&#x2F;Minimum Query 的缩写，表示可重复贡献的区间最大&#x2F;最小值。","text":"摘要：区间贡献问题的另一种更简单、更快捷的解决方案。 问题叙述 RMQ 是 Range Maximum&#x2F;Minimum Query 的缩写，表示可重复贡献的区间最大&#x2F;最小值。 显而易见的，可以用线段树实现。但是由于该问题不涉及修改操作，且线段树太长了不好写，十分浪费时间。 这是就需要用到好理解又好写的ST表了。 算法思路 ST表(Sparse Table)是用于解决可重复贡献问题的数据结构。 倍增思想：我们考虑将 $st_{i,j}$ 定义为 起点为 $i$, 到 $i + 2^j - 1$ 位置的所有元素的最大值。例如 $st_{i,1}$ 表示 $i$ 和 $i + 1$ 中的最大值。 转移过程把当前区间拆成两个大小相等的区间，用动态规划求出答案。$$st_{i,j} &#x3D; max(st_{i,j - 1},st_{i + 2^{j-1},j - 1})$$这样就可以保证该区间内所有的元素都被转移了。预处理就是将 $st_{i,0}$ 表示第 $i$ 个元素的最大值，即本身。 查询过程查询过程也一样，分成两个区间，这里我用的是 $st_{i,k}$ 和 $st_{r-2^k+1,k}$，因为这样刚好有一部分重叠，可以保证答案转移的正确性，然后分别求最大值最后在汇总一下。$$max(st_{l,k}, st_{r - 2^k + 1,k})$$其中的 k = log[r - l + 1]，用于分隔两个区间。至于怎么求 $\\log$，这里我用的是传统求 lg[i] + 1 的写法，见下方代码。 总代码例题：洛谷 P3865【模板】ST 表 &amp;&amp; RMQ 问题 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const ll MAXN = 1e5 + 5;ll st[MAXN][25], lg[MAXN];ll Query(ll l, ll r)&#123; ll k = lg[r - l + 1] - 1; return max(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; st[i][0]; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; lg[i] = lg[i - 1] + ((1 &lt;&lt; lg[i - 1]) == i); &#125; for(ll j = 1; j &lt;= 20; j ++)&#123; for(ll i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++)&#123; st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; while(m --)&#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; Query(l, r) &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 更多思考 为什么 ST表 似乎很少被用于区间求和之类的问题？ 这个问题看起来很傻，却很有用。大概有如下两个原因： 可以用前缀和，更好写还不容易错 ST表如果想要O(1)查询，需要满足所求的问题区间能够重复覆盖。因为查询是两边重叠算的啊 显然，对于第二点，区间求和并不满足条件（如果重复覆盖就会有许多值被加了多次）。那么可不可以进行二进制拆分呢？答案显然是可以的。","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"}]},{"title":"Segment Tree 线段树笔记","slug":"Segment Tree","date":"2024-10-12T16:00:00.000Z","updated":"2025-03-16T14:55:22.793Z","comments":true,"path":"2024/10/13/Segment Tree/","permalink":"https://allen2010.github.io/2024/10/13/Segment%20Tree/","excerpt":"摘要：区间求和与最值问题在算法竞赛中扮演着重要的一环。而其中伴随的区间修改，便需要用线段树来解决。 算法描述 线段树是一种能够处理区间修改和区间查询的数据结构。","text":"摘要：区间求和与最值问题在算法竞赛中扮演着重要的一环。而其中伴随的区间修改，便需要用线段树来解决。 算法描述 线段树是一种能够处理区间修改和区间查询的数据结构。 顾名思义，线段树就是一种存储着线段数据的树形结构。它的每个节点都表示一个线段区间，每个节点的孩子节点存储的就是该区间的左半段和右半段。每个线段区间都存储着一个值，一般是区间和，也有可能是区间最大&#x2F;最小值。 算法实现线段树使用数组实现，根节点编号为 $1$ 表示区间 $1$ 到 $n$，左子节点是 $i \\times 2$，右子节点是 $i \\times 2 + 1$. 12ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125; 初始化从根节点开始，不断的分割区间直到该区间只剩单个数，然后开始向上汇总。传入两个变量 l 和 r， 表示当前节点表示的线段。 1234567891011121314void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125; 区间查询从根节点开始，如果当前的线段不被查询的区间完全包含就一直分两段尝试，直到它被完全包含了，返回该线段的值然后继续递归其他的。 1234567891011121314ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125; 区间修改如果每次修改都从上到下全改一遍，复杂度得 $\\mathcal{O}(n)$ ，太浪费时间了，完全体现不出线段树的优势所在。因此引入懒标记（Lazy Tag）。和查询一样，当线段被区间完全覆盖时，对应的节点自己更新，但它的孩子们不更新。这时给他安上一个懒标记，表示它的子节点需要更新的大小。当区间没有完全覆盖，需要拆分的时候，将当前变量的标记拆掉，传给子节点，这样才不会错算。 12345678910111213141516void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125; 复杂度估算由于线段树原理是每个区间分两段，再将两端区间分别分段以此类推，又有 $n$ 个元素，因此线段树的高度是 $\\log n$ 的。而区间修改和查询最坏都要遍历一遍每一层，因此修改和查询的复杂度都是 $\\mathcal{O}\\log n$ 的，足以应付大部分题目。 总代码题目：洛谷 P3372【模板】线段树 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const ll MAXN = 1e5 + 5;ll sum[4 * MAXN], a[MAXN], tag[4 * MAXN];ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125;void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125;void moveTag(ll p, ll l, ll r, ll t)&#123; sum[p] += t * (r - l + 1); tag[p] += t;&#125;void pushDown(ll p, ll l, ll r)&#123; ll mid = (l + r) &gt;&gt; 1; moveTag(lc(p), l, mid, tag[p]); moveTag(rc(p), mid + 1, r, tag[p]); tag[p] = 0;&#125;void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125;ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); while(m --)&#123; ll o, x, y, k; cin &gt;&gt; o; if(o == 1)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; Update(1, 1, n, x, y, k); &#125;else&#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; Query(1, 1, n, x, y) &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"divide & conquer","slug":"divide-conquer","permalink":"https://allen2010.github.io/tags/divide-conquer/"}]},{"title":"Floyd 全源最短路径算法笔记","slug":"Floyd","date":"2024-10-12T16:00:00.000Z","updated":"2025-03-16T14:55:36.099Z","comments":true,"path":"2024/10/13/Floyd/","permalink":"https://allen2010.github.io/2024/10/13/Floyd/","excerpt":"摘要：多源最短路径最简单、最实用、最好理解，同时也是最慢的经典算法。 算法描述 三个破变量，一共就十行。编程十分钟，运行一晚上。","text":"摘要：多源最短路径最简单、最实用、最好理解，同时也是最慢的经典算法。 算法描述 三个破变量，一共就十行。编程十分钟，运行一晚上。 很多人认为 Floyd 就是简单的动态规划，甚至有人直接把它当模板背了下来，导致不会变通而 WA 了 P1119。然而其实大多数初学者包括我一开始都理解错了它，包括原理。 算法实现定义 $dis_{i,j}^k$ 表示只包含前 $k$ 个节点时 $i$ 到 $j$ 的最短路。而加不加入这个 $k$ 号元素前后有什么区别呢？无非就是某两个点的最短路通过 $k$ 号点松弛出了更有的最短路嘛。于是就有了经典代码： 123456789void Floyd()&#123; for(ll k = 1; k &lt;= n; k ++)&#123; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;&#125; 那么如何初始化呢？如果 $i$ 到 $j$ 有路，就初始化为边长。否则初始化为最大值。 1234567for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; if(i == j)dis[i][j] = 0; else if(gph[i][j])dis[i][j] = gph[i][j]; else dis[i][j] = INF; &#125;&#125; 这就完了吗？这值得写博客吗？当然不值。虽然我本来就是给自己写来复习的 Floyd应用Floyd解决传递闭包问题题目传送门 在有向图中，定义 $d_{i,j}$ 如果是 1，则表示 $i$ 能到达 $j$，否则反之。 这该如何解决呢？转换一下定义。定义 $d_{i,j}^k$ 表示只有前 $k$ 个点时 $i$ 能否到达 $j$。同理，加入了一个元素 $k$ 之后无非就是有一组 $i$ 能通过它到达 $j$ 了。 123456789101112131415161718192021void Floyd()&#123; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; if(graph[i][j])d[i][j] = 1; else d[i][j] = 0; &#125; &#125; for(ll k = 1; k &lt;= n; k ++)&#123; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; d[i][j] = d[i][j] || (d[i][k] &amp;&amp; d[k][j]); &#125; &#125; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; cout &lt;&lt; d[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125; Floyd求最小环依旧是改定义：$d_{i,j}^k$ 为前 $k$ 个节点中可以确定的最小环的大小。则匹配最短路，可以在算最短路之后算环了，可以理解为以 $k$ 为一个顶点，由 $k$ 可以到达的 $i$ 和 $j$ 以及 $dis_{i,j}$ 也就是最短路构成的环。然后枚举已经算出最短路的 $i,j$ 即可。例题就是 P2738 篱笆回路。这题输入特别逆天，所以给了完整代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const ll MAXN = 305;const ll INF = 2147483647;struct Edge&#123; ll u, v, w; bool lside[MAXN], rside[MAXN];&#125;edge[MAXN]; ll adj[MAXN][MAXN], father[MAXN], m, n, idx[MAXN], dis[MAXN][MAXN];ll find(ll x)&#123; if(father[x] == x)return x; return father[x] = find(father[x]);&#125;void merge(ll x, ll y)&#123; father[find(x)] = find(y);&#125;ll Floyd()&#123; ll ans = INF; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; if(!dis[i][j])dis[i][j] = INF; if(!adj[i][j])adj[i][j] = INF; &#125; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; adj[i][i] = dis[i][i] = 0; &#125; for(ll k = 1; k &lt;= n; k ++)&#123; for(ll i = 1; i &lt;= k - 1; i ++)&#123; for(ll j = i + 1; j &lt;= k - 1; j ++)&#123; ans = min(ans, adj[i][k] + adj[k][j] + dis[i][j]); &#125; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; m; for(ll i = 1; i &lt;= m; i ++)&#123; ll s, len, numl, numr, id; cin &gt;&gt; s &gt;&gt; len &gt;&gt; numl &gt;&gt; numr; edge[s].u = s * 2 - 1; edge[s].v = s * 2; edge[s].w = len; for(ll j = 1; j &lt;= numl; j ++)&#123; cin &gt;&gt; id; edge[s].lside[id] = 1; &#125; for(ll j = 1; j &lt;= numr; j ++)&#123; cin &gt;&gt; id; edge[s].rside[id] = 1; &#125; &#125; for(ll i = 1; i &lt;= 250; i ++)&#123; father[i] = i; &#125; for(ll i = 1; i &lt;= m; i ++)&#123; for(ll j = 1; j &lt;= m; j ++)&#123; if(i == j)continue; if(edge[i].lside[j] &amp;&amp; edge[j].lside[i])&#123; merge(edge[i].u, edge[j].u); &#125; if(edge[i].lside[j] &amp;&amp; edge[j].rside[i])&#123; merge(edge[i].u, edge[j].v); &#125; if(edge[i].rside[j] &amp;&amp; edge[j].lside[i])&#123; merge(edge[i].v, edge[j].u); &#125; if(edge[i].rside[j] &amp;&amp; edge[j].rside[i])&#123; merge(edge[i].v, edge[j].v); &#125; &#125; &#125; for(ll i = 1; i &lt;= 2 * m; i ++)&#123; if(father[i] == i)&#123; idx[i] = ++n; &#125; &#125; for(ll i = 1; i &lt;= m; i ++)&#123; edge[i].u = idx[find(edge[i].u)]; edge[i].v = idx[find(edge[i].v)]; adj[edge[i].u][edge[i].v] = edge[i].w; adj[edge[i].v][edge[i].u] = edge[i].w; dis[edge[i].u][edge[i].v] = edge[i].w; dis[edge[i].v][edge[i].u] = edge[i].w; &#125; cout &lt;&lt; Floyd() &lt;&lt; &quot;\\n&quot;; return 0;&#125; 总结Floyd 算法似乎从方方面面看都很平庸：时间复杂度高达 $\\mathcal{O}(n^3)$，需要空间复杂度耗费较大的邻接矩阵存图，甚至连模板的使用环境都比较小。然而 Floyd 算法具有较高的灵活性、可读性和可写性。一旦深刻理解了它的原理，就可以加以变通，解决许许多多看似复杂的算法。以上就是例子，希望大家不要想我最初一样，只背了模板，没有思考含义。 Floyd 算法之所以被发明出来，并不是因为他比 Dijkstra 更快，比 SPFA 更好理解，而是因为，他善啊…… 推荐例题：洛谷 P1119 灾后重建，P1841 重要的城市","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"shortest path","slug":"shortest-path","permalink":"https://allen2010.github.io/tags/shortest-path/"}]}],"categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"shortest path","slug":"shortest-path","permalink":"https://allen2010.github.io/tags/shortest-path/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"divide & conquer","slug":"divide-conquer","permalink":"https://allen2010.github.io/tags/divide-conquer/"}]}