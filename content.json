{"meta":{"title":"Allen2010 Blog","subtitle":"Explore Here!","description":"BlackBasalt","author":"Allenyang","url":"https://allen2010.github.io","root":"/"},"pages":[{"title":"","date":"2025-01-27T10:19:59.884Z","updated":"2025-01-27T10:19:59.884Z","comments":true,"path":"about/index.html","permalink":"https://allen2010.github.io/about/index.html","excerpt":"","text":"个人资料 出生年份：2010年北京 爱好：编程、写小说片段 基本资料： 初二 Luogu OIer，没什么水平，爱好算法。喜欢诸如 The Lord of the Rings 和 A Song of Ice and Fire 之类的奇幻小说。喜欢写一些以 MC 和自然为主题的冒险小说片段。"},{"title":"文章分类","date":"2021-01-25T14:37:25.000Z","updated":"2025-03-16T00:12:10.637Z","comments":true,"path":"categories/index.html","permalink":"https://allen2010.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-25T14:54:58.000Z","updated":"2025-03-16T00:11:06.974Z","comments":true,"path":"tags/index.html","permalink":"https://allen2010.github.io/tags/index.html","excerpt":"","text":""},{"title":"FRIENDS","date":"2025-01-27T04:21:54.497Z","updated":"2025-01-27T04:21:54.497Z","comments":true,"path":"friends/index.html","permalink":"https://allen2010.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2025-02-26T13:36:12.282Z","updated":"2025-02-26T13:36:12.282Z","comments":true,"path":"css/custom.css","permalink":"https://allen2010.github.io/css/custom.css","excerpt":"","text":"@font-face { /* 为载入的字体取名字(随意) */ font-family: 'LXGWWenKai-Regular'; /* 字体文件地址(相对或者绝对路径都可以) */ src: url(fonts/TTF/LXGWWenKai-Regular.ttf); /* 定义加粗样式(加粗多少) */ font-weight: normal; /* 定义字体样式(斜体/非斜体) */ font-style: normal; /* 定义显示样式 */ font-display: block; }"}],"posts":[{"title":"Segment Tree 线段树笔记","slug":"Segment Tree","date":"2025-01-26T16:00:00.000Z","updated":"2025-03-16T07:24:09.046Z","comments":true,"path":"2025/01/27/Segment Tree/","permalink":"https://allen2010.github.io/2025/01/27/Segment%20Tree/","excerpt":"","text":"算法描述 线段树是一种能够处理区间修改和区间查询的数据结构。 顾名思义，线段树就是一种存储着线段数据的树形结构。它的每个节点都表示一个线段区间，每个节点的孩子节点存储的就是该区间的左半段和右半段。每个线段区间都存储着一个值，一般是区间和，也有可能是区间最大&#x2F;最小值。 算法实现线段树使用数组实现，根节点编号为 $1$ 表示区间 $1$ 到 $n$，左子节点是 $i \\times 2$，右子节点是 $i \\times 2 + 1$. 12ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125; 初始化从根节点开始，不断的分割区间直到该区间只剩单个数，然后开始向上汇总。传入两个变量 l 和 r， 表示当前节点表示的线段。 1234567891011121314void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125; 区间查询从根节点开始，如果当前的线段不被查询的区间完全包含就一直分两段尝试，直到它被完全包含了，返回该线段的值然后继续递归其他的。 1234567891011121314ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125; 区间修改如果每次修改都从上到下全改一遍，复杂度得 $\\mathcal{O}(n)$ ，太浪费时间了，完全体现不出线段树的优势所在。因此引入懒标记（Lazy Tag）。和查询一样，当线段被区间完全覆盖时，对应的节点自己更新，但它的孩子们不更新。这时给他安上一个懒标记，表示它的子节点需要更新的大小。当区间没有完全覆盖，需要拆分的时候，将当前变量的标记拆掉，传给子节点，这样才不会错算。 12345678910111213141516void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125; 复杂度估算由于线段树原理是每个区间分两段，再将两端区间分别分段以此类推，又有 $n$ 个元素，因此线段树的高度是 $\\log n$ 的。而区间修改和查询最坏都要遍历一遍每一层，因此修改和查询的复杂度都是 $\\mathcal{O}\\log n$ 的，足以应付大部分题目。 总代码题目：洛谷 P3372【模板】线段树 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const ll MAXN = 1e5 + 5;ll sum[4 * MAXN], a[MAXN], tag[4 * MAXN];ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125;void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125;void moveTag(ll p, ll l, ll r, ll t)&#123; sum[p] += t * (r - l + 1); tag[p] += t;&#125;void pushDown(ll p, ll l, ll r)&#123; ll mid = (l + r) &gt;&gt; 1; moveTag(lc(p), l, mid, tag[p]); moveTag(rc(p), mid + 1, r, tag[p]); tag[p] = 0;&#125;void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125;ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); while(m --)&#123; ll o, x, y, k; cin &gt;&gt; o; if(o == 1)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; Update(1, 1, n, x, y, k); &#125;else&#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; Query(1, 1, n, x, y) &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"}]},{"title":"Sparse Table ST表笔记","slug":"Sparse Table","date":"2025-01-26T16:00:00.000Z","updated":"2025-03-16T07:25:36.297Z","comments":true,"path":"2025/01/27/Sparse Table/","permalink":"https://allen2010.github.io/2025/01/27/Sparse%20Table/","excerpt":"","text":"问题叙述 RMQ 是 Range Maximum&#x2F;Minimum Query 的缩写，表示可重复贡献的区间最大&#x2F;最小值。 显而易见的，可以用线段树实现。但是由于该问题不涉及修改操作，且线段树太长了不好写，十分浪费时间。 这是就需要用到好理解又好写的ST表了。 算法思路 ST表(Sparse Table)是用于解决可重复贡献问题的数据结构。 倍增思想：我们考虑将 $st_{i,j}$ 定义为 起点为 $i$, 到 $i + 2^j - 1$ 位置的所有元素的最大值。例如 $st_{i,1}$ 表示 $i$ 和 $i + 1$ 中的最大值。 该如何处理转移过程？把当前区间拆成两个大小相等的区间，用动态规划求出答案。$$st_{i,j} &#x3D; max(st_{i,j - 1},st_{i + 2^{j-1},j - 1})$$这样就可以保证该区间内所有的元素都被转移了。预处理就是将 $st_{i,0}$ 表示第 $i$ 个元素的最大值，即本身。 查询过程？查询过程也一样，分成两个区间，这里我用的是 $st_{i,k}$ 和 $st_{r-2^k+1,k}$，因为这样刚好有一部分重叠，可以保证答案转移的正确性，然后分别求最大值最后在汇总一下。$$max(st_{l,k}, st_{r - 2^k + 1,k})$$其中的 k = log[r - l + 1]，用于分隔两个区间。至于怎么求 $\\log$，这里我用的是传统求 lg[i] + 1 的写法，见下方代码。 总代码例题：洛谷 P3865【模板】ST 表 &amp;&amp; RMQ 问题 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const ll MAXN = 1e5 + 5;ll st[MAXN][25], lg[MAXN];ll Query(ll l, ll r)&#123; ll k = lg[r - l + 1] - 1; return max(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; st[i][0]; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; lg[i] = lg[i - 1] + ((1 &lt;&lt; lg[i - 1]) == i); &#125; for(ll j = 1; j &lt;= 20; j ++)&#123; for(ll i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++)&#123; st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; while(m --)&#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; Query(l, r) &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 更多思考 为什么 ST表 似乎很少被用于区间求和之类的问题？ 这个问题看起来很傻，却很有用。大概有如下两个原因： 可以用前缀和，更好写还不容易错 ST表如果想要O(1)查询，需要满足所求的问题区间能够重复覆盖。因为查询是两边重叠算的啊 显然，对于第二点，区间求和并不满足条件（如果重复覆盖就会有许多值被加了多次）。那么可不可以进行二进制拆分呢？答案显然是可以的。","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"}]}],"categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"}]}