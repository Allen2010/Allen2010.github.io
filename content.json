{"meta":{"title":"Allen2010 Blog","subtitle":"Explore Here!","description":"BlackBasalt","author":"Allenyang","url":"https://allen2010.github.io","root":"/"},"pages":[{"title":"About","date":"2025-03-21T13:33:01.000Z","updated":"2025-04-13T13:32:09.466Z","comments":true,"path":"about/index.html","permalink":"https://allen2010.github.io/about/index.html","excerpt":"","text":"About Me I’m Allen2010, as known as “Allen_yang” in Luogu, a Chinese 8th grade students. 大家好，这里是 Allen2010 的博客。我是一名中国北京市初二学生，在洛谷账号为 Allen_yang(uid:683768)。一名很菜的 OIer，低端的小说家和落魄的理科生。虽打着信息学竞赛生的名号，却主攻文化课。擅长数学，物理略好，其他的中等偏上。主要爱好目前有： 写小说，以奇幻、冒险或其他非传统网络小说为主题 学算法，写代码，顺便发表算法笔记 打 Atcoder 和 Luogu 比赛 设计建筑，重要应用 Sketch Up 草图大师 自然风光，例如 热带稀树草原 温带疏林草原 热带雨林 海滩 雪景 打羽球（反正你也看不到） Blog Topic我将在这个博客上发表一些自己原创的文章，分类的介绍如下 Note 算法笔记学习算法后的感悟、总结以及对算法实现的见解 Works 建模渲染作品、画作建模作品的渲染图、作品介绍以及理念。建筑设计为主。 Essay 随笔随笔。 Novel 小说个人爱好，文笔不佳。以奇幻、冒险等元素构成的小说（也可能是片段），风格新奇。 Favourite 爱好大概是关于主要爱好的一些杂念，无关紧要。 History本博客搭建于 2024 年，应用于 2025 年。经历从 volantis 到 NexT 再到 Redefine 主题的转变，我的审美和风格发生了很大转变。现在，文笔将以简洁明了为主，去除骈文式的繁杂语句和自创揉词awa。"},{"title":"文章分类","date":"2021-01-25T14:37:25.000Z","updated":"2025-03-16T00:12:10.637Z","comments":true,"path":"categories/index.html","permalink":"https://allen2010.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-02-26T13:36:12.282Z","updated":"2025-02-26T13:36:12.282Z","comments":true,"path":"css/custom.css","permalink":"https://allen2010.github.io/css/custom.css","excerpt":"","text":"@font-face { /* 为载入的字体取名字(随意) */ font-family: 'LXGWWenKai-Regular'; /* 字体文件地址(相对或者绝对路径都可以) */ src: url(fonts/TTF/LXGWWenKai-Regular.ttf); /* 定义加粗样式(加粗多少) */ font-weight: normal; /* 定义字体样式(斜体/非斜体) */ font-style: normal; /* 定义显示样式 */ font-display: block; }"},{"title":"FRIENDS","date":"2025-01-27T04:21:54.497Z","updated":"2025-01-27T04:21:54.497Z","comments":true,"path":"friends/index.html","permalink":"https://allen2010.github.io/friends/index.html","excerpt":"","text":""},{"title":"Friends","date":"2025-03-27T12:32:07.000Z","updated":"2025-03-27T12:32:49.681Z","comments":true,"path":"links/index.html","permalink":"https://allen2010.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-25T14:54:58.000Z","updated":"2025-03-16T00:11:06.974Z","comments":true,"path":"tags/index.html","permalink":"https://allen2010.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SketchUp Works Ep.1","slug":"Sketch1","date":"2025-04-13T13:05:05.000Z","updated":"2025-04-13T13:28:14.997Z","comments":true,"path":"2025/04/13/Sketch1/","permalink":"https://allen2010.github.io/2025/04/13/Sketch1/","excerpt":"Here's some of my most beautiful SketchUp works!","text":"Intro这是一些我用 Sketch Up 设计的、用 Twinmotion 渲染的建筑预览图！设计新手，有诸多缺陷，望见谅 Sunny day Rainy day Before sunrise","categories":[{"name":"Works","slug":"Works","permalink":"https://allen2010.github.io/categories/Works/"}],"tags":[{"name":"sketch","slug":"sketch","permalink":"https://allen2010.github.io/tags/sketch/"},{"name":"design","slug":"design","permalink":"https://allen2010.github.io/tags/design/"}]},{"title":"Best Badminton Player","slug":"Badminton","date":"2025-04-03T09:32:05.000Z","updated":"2025-04-14T12:06:12.106Z","comments":true,"path":"2025/04/03/Badminton/","permalink":"https://allen2010.github.io/2025/04/03/Badminton/","excerpt":"Here's the ranking of the Best Badminton Player in my mind.","text":"Here RankingHere’s the ranking of the Best Men’s Singles Badminton Player in my mind. 这里是一个我认为的羽球男单著名选手排名 No.1 Lin Dan林丹，中国前羽毛球运动员。最高排名世界第一位，因其球风凶悍、个性鲜明，于2004年全英赛击败丹麦选手彼得·盖德夺冠后，被对方称为 Super Dan。林丹被公认为同时代实力最强的羽毛球运动员，被誉为羽毛球历史上最伟大的球员。他与马来西亚华裔球手李宗伟的多次对决也被誉为男单史上最高水准对决，被球迷称为“林李大战”。 Wiki-林丹 No.2 Lee Chong Wei拿督威拉李宗伟，马来西亚华人运动员，已退役的羽毛球男子单打运动员，被称为“大马羽毛球一哥”，作为男单运动员，李宗伟在2008年8月21日成为国际羽联世界排名第一的球手。 Wiki-李宗伟 No.3 Chen Long谌龙，中国退役男子羽毛球运动员，于2016年里约奥运会羽毛球项目男子单打取得金牌。技术特点为擅于防守反击、突击爆发力强。现为中国国家青年羽毛球队教练。 Wiki-谌龙 No.4 Taufik陶菲克·希达亚特（印尼语：Taufik Hidayat），印尼男子羽毛球运动员，他与丹麦的彼得·盖德、中国的林丹和马来西亚的李宗伟并称国际羽坛四大天王。 Wiki-陶菲克 No.5 Viktor Axelsen维克托·阿克塞尔森（丹麦语：Viktor Axelsen），汉名安赛龙，丹麦羽毛球男子单打运动员。安赛龙是丹麦历史上首位世青赛男单冠军。2021年8月，他在东京奥运羽毛球单打决赛中以2比0击败谌龙，成为自2004年奥运以后首位夺得羽毛球男单冠军的非中国球员。 Wiki-安赛龙 No.6 Kento Momota桃田贤斗（Kento Momota），日本羽毛球男子单打运动员，日本首位男单羽毛球世锦赛冠军、卫冕者及世界排名第一的男子单打选手。 Wiki-桃田贤斗 注：关于安赛龙和桃田的排名问题 由于桃田在比赛中击败安赛龙的次数远高于败于他的次数，可能会引起为何安赛龙排名比桃田高的疑虑。首先，这是个人排名，也就是我自己心中一个羽毛球男单运动员的实力排名。桃田由于不可控因素，统治羽球界的时间比安赛龙短。且我认为人品也是评价运动员实力的因素，而桃田曾因违反规定而被禁赛，自然在我心中形象会有所降低。不过桃田也确实是个正人君子，这点需要明确。其次，其实排名 5-7 名的界限并不是很明确，我都是跟着第一感觉来的，也没有必要较汁了。 No.7 Peter Gade彼得·盖德（丹麦语：Peter Gade），丹麦退役男子羽毛球单打运动员，与印尼的陶菲克、中国的林丹和马来西亚的李宗伟并称国际羽坛“四大天王”。他的选手生涯之长冠绝当年羽坛，因此又被人称为羽坛“常青树”，并曾经缔造连续62周排名世界第一的纪录。 Wiki-彼得·盖德 No.8 Shi Yu Qi 淡黄的长裙…… 石宇奇，中国羽毛球男子单打运动员。 Wiki-石宇奇 No.9 Lee Zii Jia李梓嘉（英语：Lee Zii Jia），马来西亚男子羽毛球运动员。2024年巴黎奥运会羽毛球男单铜牌获得者。 Wiki-李梓嘉 AchievementMajor events only. Olympic Games奥林匹克夏季运动会 Olympic 夏季奥运会奖牌 BWF World Championships世界羽毛球锦标赛 BWF 世锦赛 All England全英羽毛球公开锦标赛（All England Open Badminton Championships） All England 全英公开赛 Gallery","categories":[{"name":"Favourite","slug":"Favourite","permalink":"https://allen2010.github.io/categories/Favourite/"}],"tags":[{"name":"badminton","slug":"badminton","permalink":"https://allen2010.github.io/tags/badminton/"},{"name":"personal thought","slug":"personal-thought","permalink":"https://allen2010.github.io/tags/personal-thought/"}]},{"title":"Segment Tree 线段树笔记","slug":"Segment Tree","date":"2025-03-21T16:00:00.000Z","updated":"2025-04-06T12:02:51.608Z","comments":true,"path":"2025/03/22/Segment Tree/","permalink":"https://allen2010.github.io/2025/03/22/Segment%20Tree/","excerpt":"区间求和与最值等区间问题在算法竞赛中扮演着重要的一环。而其中伴随的区间修改，便需要用线段树来解决。","text":"算法描述 线段树常用于解决区间修改查询问题，包括但不限于最大值、最小值和求和。线段树最大的难点，就是你不知道它将用来解决怎样的问题。 定义线段树就是一棵普普通通的树，它的大部分节点都有两个子节点，但并不是一棵满二叉树，也不是完全二叉树。这一点你在学习后面的文章后就会明白了。线段树上每一个节点都代表着一段区间，而每个子结点代表的区间长度都是其父节点的一半。若长度是奇数则会有些许偏差。而节点的值则是这个区间的需求。 应用线段树可以解决大部分的区间问题，只要你能想清楚怎么分治，基本上就是线段树没得跑。哪怕这个区间的需求是连续的。通常来说，线段树的操作分为以下几种： 建树：输入数组并建立对应需求的线段树 单点修改：将 位置的元素改成 区间修改：将 到 位置的所用元素改成或增加 区间查询：查询 到 区间内的最大/最小/和/其他需求 算法实现线段树用数组实现。注意数组大小要开到 。左右子树的编号分别是 和 。12ll lc(ll p){return p &lt;&lt; 1;}ll rc(ll p){return p &lt;&lt; 1 | 1;} 初始化从根节点开始，不断的分割区间直到该区间只剩单个数，然后开始向上汇总。传入两个变量 l 和 r， 表示当前节点表示的线段。1234567891011121314void pushUp(ll p){ sum[p] = sum[lc(p)] + sum[rc(p)];}void build(ll p, ll l, ll r){ if(l == r){ sum[p] = a[l]; return; } ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); } 区间查询从根节点开始，如果当前的线段不被查询的区间完全包含就一直分两段尝试，直到它被完全包含了，返回该线段的值然后继续递归其他的。1234567891011121314ll Query(ll p, ll l, ll r, ll ql, ll qr){ if(ql &lt;= l &amp;&amp; qr &gt;= r){ return sum[p]; } pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid){ ans += Query(lc(p), l, mid, ql, qr); } if(qr &gt; mid){ ans += Query(rc(p), mid + 1, r, ql, qr); } return ans;} 区间修改如果每次修改都从上到下全改一遍，复杂度得 ，太浪费时间了，完全体现不出线段树的优势所在。因此引入懒标记（Lazy Tag）。和查询一样，当线段被区间完全覆盖时，对应的节点自己更新，但它的孩子们不更新。这时给他安上一个懒标记，表示它的子节点需要更新的大小。当区间没有完全覆盖，需要拆分的时候，将当前变量的标记拆掉，传给子节点，这样才不会错算。12345678910111213141516void Update(ll p, ll l, ll r, ll ql, ll qr, ll d){ if(ql &lt;= l &amp;&amp; qr &gt;= r){ sum[p] += d * (r - l + 1); tag[p] += d; return; } pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid){ Update(lc(p), l, mid, ql, qr, d); } if(qr &gt; mid){ Update(rc(p), mid + 1, r, ql, qr, d); } pushUp(p);} 例题例题：Luogu P3372123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 5;ll segt[4 * MAXN], tag[4 * MAXN], a[MAXN];ll lc(ll p){return p &lt;&lt; 1;}ll rc(ll p){return p &lt;&lt; 1 | 1;}void pushUp(ll p){ segt[p] = min(segt[lc(p)], segt[rc(p)]);}void build(ll p, ll l, ll r){ if(l == r){ segt[p] = a[l]; return; } ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p);}void moveTag(ll p, ll k){ tag[p] += k; segt[p] += k;}void pushDown(ll p){ moveTag(lc(p), tag[p]); moveTag(rc(p), tag[p]); tag[p] = 0;}void Update(ll p, ll l, ll r, ll ql, ll qr){ if(ql &lt;= l &amp;&amp; qr &gt;= r){ moveTag(p, 1); return; } pushDown(p); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)Update(lc(p), l, mid, ql, qr); if(qr &gt; mid)Update(rc(p), mid + 1, r, ql, qr); pushUp(p);}ll Query(ll p, ll l, ll r, ll ql, ll qr){ if(ql &lt;= l &amp;&amp; qr &gt;= r){ return segt[p]; } pushDown(p); ll mid = (l + r) &gt;&gt; 1, ans = 2147483647; if(ql &lt;= mid)ans = min(ans, Query(lc(p), l, mid, ql, qr)); if(qr &gt; mid)ans = min(ans, Query(rc(p), mid + 1, r, ql, qr)); return ans;}int main(){ ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++){ cin &gt;&gt; a[i]; } build(1, 1, n); while(m --){ ll opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if(opt == 1){ Update(1, 1, n, l, r); }else{ cout &lt;&lt; Query(1, 1, n, l, r) &lt;&lt; \"\\n\"; } } return 0;} 变种区间和并在遇到有区间连续的需求时，我们发现传统线段树并不适用，因为分段时无法控制答案的范围，在向上整理回父节点时可能会遇到答案的中间部分没有连接但却错误转移的情况。我们可以定义额外的变量存于线段树的数组，分别表示了以区间最左边和最右边起始的答案，这样就只需要思考如何 pushUp 转移了。 例题例题：区间最大连续子序列和输入一个长度为 的数组 ，数组的元素均为整数且满足 。对该数组可以发出 条指令。指令共有 种： 1 x v，该指令将 的值修改为 2 l r，该指令查询区间 到 的最大连续子序列和，即区间所有可能的连续子序列中求和的最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;typedef long long ll;const ll MAXN = 400005, fINF = LONG_LONG_MIN;struct Node{ ll sum = 0, lans = fINF, rans = fINF, ans = fINF;}segt[4 * MAXN];ll a[MAXN];ll lc(ll p){return p &lt;&lt; 1;}ll rc(ll p){return p &lt;&lt; 1 | 1;}void pushUp(ll p){ segt[p].sum = segt[lc(p)].sum + segt[rc(p)].sum; segt[p].lans = max({segt[lc(p)].sum + segt[rc(p)].lans, segt[lc(p)].lans}); segt[p].rans = max({segt[rc(p)].sum + segt[lc(p)].rans, segt[rc(p)].rans}); segt[p].ans = max({segt[lc(p)].rans + segt[rc(p)].lans, segt[lc(p)].ans, segt[rc(p)].ans});}void build(ll p, ll l, ll r){ if(l == r){ segt[p].ans = segt[p].lans = segt[p].rans = segt[p].sum = a[l]; return; } ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p);}void Update(ll p, ll l, ll r, ll x, ll v){ if(l == r){ segt[p].sum = segt[p].ans = segt[p].lans = segt[p].rans = v; return; } ll mid = (l + r) &gt;&gt; 1; if(x &lt;= mid)Update(lc(p), l, mid, x, v); else if(x &gt; mid)Update(rc(p), mid + 1, r, x, v); pushUp(p);}Node Query(ll p, ll l, ll r, ll ql, ll qr){ if(ql &lt;= l &amp;&amp; qr &gt;= r){ return segt[p]; } ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid &amp;&amp; qr &gt; mid){ Node ans, qla = Query(lc(p), l, mid, ql, qr), qra = Query(rc(p), mid + 1, r, ql, qr); ans.sum = qla.sum + qra.sum; ans.ans = max({ans.ans, qla.ans, qra.ans, qla.rans + qra.lans}); ans.lans = max({ans.lans, qla.lans, qla.sum + qra.lans}); ans.rans = max({ans.rans, qra.rans, qra.sum + qla.rans}); return ans; }else if(ql &lt;= mid){ return Query(lc(p), l, mid, ql, qr); }else{ return Query(rc(p), mid + 1, r, ql, qr); }}int main(){ ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++){ cin &gt;&gt; a[i]; } build(1, 1, n); while(m --){ ll opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if(opt == 1){ Update(1, 1, n, l, r); }else{ cout &lt;&lt; Query(1, 1, n, l, r).ans &lt;&lt; \"\\n\"; } } return 0;} 总结极为常用，需要会用、会推、会写且达到熟练的地步。复杂度 ，已经很快了。","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"divide & conquer","slug":"divide-conquer","permalink":"https://allen2010.github.io/tags/divide-conquer/"}]},{"title":"更换主题 Redefine","slug":"New Theme","date":"2025-03-21T11:07:05.000Z","updated":"2025-04-13T11:28:45.557Z","comments":true,"path":"2025/03/21/New Theme/","permalink":"https://allen2010.github.io/2025/03/21/New%20Theme/","excerpt":"我更换了一个新主题！","text":"New ThemeHey guys, Allen2010 here!I use a new Hexo Theme Redefine!It’s Better!我更换了新的主题，以此纪念。","categories":[{"name":"Theme","slug":"Theme","permalink":"https://allen2010.github.io/categories/Theme/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://allen2010.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://allen2010.github.io/tags/Theme/"}]},{"title":"LCA 最近共同祖先算法笔记","slug":"Lowest Common Ancestor","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-26T10:46:38.213Z","comments":true,"path":"2025/03/02/Lowest Common Ancestor/","permalink":"https://allen2010.github.io/2025/03/02/Lowest%20Common%20Ancestor/","excerpt":"对于一棵树上任意两个节点的最近共同祖先问题，能否用倍增法解决？","text":"算法描述 恐龙，是指三角龙、现代鸟类和梁龙的最近共同祖先 (LCA) 及其所有后代。 ——百度百科 假设有一棵树，上面有两个节点，求两个节点最近的共同祖先节点。也可以理解为包含这两个节点的子树是从什么时候分开的。 算法思路 一生二，二生四，四生万物。 ——泥土笨笨 采用倍增的思想，将查询最近共同祖先问题分成若干部： 预处理预处理一个数组 anc[i][j] 表示 节点的 号祖先的编号。其中有 anc[i][j] = anc[anc[i][j - 1]][j - 1]; 意思是 的 祖先就是 的 的祖先的 祖先。通过这个式子就可以转移了。转移过程中同时预处理 数组表示深度，后面会用到。123456789101112void dfs(ll u, ll father){ //该节点和它的父亲节点 dep[u] = dep[father] + 1; //预处理深度 anc[u][0] = father; //i 的 第一个祖先，即父亲。 for(ll i = 1; (1 &lt;&lt; i) &lt;= dep[u]; i ++){ anc[u][i] = anc[anc[u][i - 1]][i - 1]; //转移，由于是从小到大枚举的j，所以当前的anc转移一定是正确的 } for(ll i = head[u]; i; i = pool[i].next){ //往下递归 if(pool[i].v != father){ dfs(pool[i].v, u); } }} 调整深度追平深度。顾名思义，通过不断调整深度让需要查询的两个节点深度相等。123456if(dep[x] &lt; dep[y]){ swap(x, y);}while(dep[x] &gt; dep[y]){ x = anc[x][lg[dep[x] - dep[y]] - 1];} 跳跃结算一起往上调，跳的步数从 步开始不断尝试，如果调完了发现重合，就放弃，然后尝试少跳一点，以此类推。直到最后到达了最接近共同祖先的位置，即共同祖先的孩子节点。为什么重合要放弃？因为谁也没办法保证当前的重合点是最近的，要不断尝试下调就太麻烦了。12345678if(x == y)return x;for(ll i = lg[dep[x]]; i &gt;= 0; i --){ if(anc[x][i] != anc[y][i]){ x = anc[x][i]; y = anc[y][i]; }}return anc[x][0]; 总代码例题：洛谷 P3379 【模板】 最近公共祖先（LCA）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const ll MAXN = 500005;struct Node{ ll v, next;}pool[2 * MAXN];ll anc[MAXN][25], dep[MAXN], head[MAXN], nn, lg[MAXN];ll n, m, s;void addEdge(ll u, ll v){ pool[++nn].v = v; pool[nn].next = head[u]; head[u] = nn;}void dfs(ll u, ll father){ dep[u] = dep[father] + 1; anc[u][0] = father; for(ll i = 1; (1 &lt;&lt; i) &lt;= dep[u]; i ++){ anc[u][i] = anc[anc[u][i - 1]][i - 1]; } for(ll i = head[u]; i; i = pool[i].next){ if(pool[i].v != father){ dfs(pool[i].v, u); } }}ll lca(ll x, ll y){ if(dep[x] &lt; dep[y]){ swap(x, y); } while(dep[x] &gt; dep[y]){ x = anc[x][lg[dep[x] - dep[y]] - 1]; } if(x == y)return x; for(ll i = lg[dep[x]]; i &gt;= 0; i --){ if(anc[x][i] != anc[y][i]){ x = anc[x][i]; y = anc[y][i]; } } return anc[x][0];}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for(ll i = 1; i &lt;= n - 1; i ++){ ll x, y; cin &gt;&gt; x &gt;&gt; y; addEdge(x, y); addEdge(y, x); } for(ll i = 1; i &lt;= n; i ++){ lg[i] = lg[i - 1] + ((1 &lt;&lt; lg[i - 1]) == i); } dfs(s, 0); for(ll i = 1; i &lt;= m; i ++){ ll x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(x, y) &lt;&lt; \"\\n\"; } return 0;}","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"}]},{"title":"Sparse Table ST表笔记","slug":"Sparse Table","date":"2025-02-21T16:00:00.000Z","updated":"2025-03-25T14:24:36.565Z","comments":true,"path":"2025/02/22/Sparse Table/","permalink":"https://allen2010.github.io/2025/02/22/Sparse%20Table/","excerpt":"区间贡献问题的另一种更简单、更快捷的解决方案。","text":"问题叙述 RMQ 是 Range Maximum/Minimum Query 的缩写，表示可重复贡献的区间最大/最小值。 显而易见的，可以用线段树实现。但是由于该问题不涉及修改操作，且线段树太长了不好写，十分浪费时间。 这是就需要用到好理解又好写的ST表了。 算法思路 ST表(Sparse Table)是用于解决可重复贡献问题的数据结构。 倍增思想：我们考虑将 定义为 起点为 , 到 位置的所有元素的最大值。例如 表示 和 中的最大值。 转移过程把当前区间拆成两个大小相等的区间，用动态规划求出答案。 st_{i,j} = max(st_{i,j - 1},st_{i + 2^{j-1},j - 1})这样就可以保证该区间内所有的元素都被转移了。预处理就是将 表示第 个元素的最大值，即本身。 查询过程查询过程也一样，分成两个区间，这里我用的是 和 ，因为这样刚好有一部分重叠，可以保证答案转移的正确性，然后分别求最大值最后在汇总一下。 max(st_{l,k}, st_{r - 2^k + 1,k})其中的 k = log[r - l + 1]，用于分隔两个区间。至于怎么求 ，这里我用的是传统求 lg[i] + 1 的写法，见下方代码。 总代码例题：洛谷 P3865【模板】ST 表 &amp;&amp; RMQ 问题12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const ll MAXN = 1e5 + 5;ll st[MAXN][25], lg[MAXN];ll Query(ll l, ll r){ ll k = lg[r - l + 1] - 1; return max(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]);}int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++){ cin &gt;&gt; st[i][0]; } for(ll i = 1; i &lt;= n; i ++){ lg[i] = lg[i - 1] + ((1 &lt;&lt; lg[i - 1]) == i); } for(ll j = 1; j &lt;= 20; j ++){ for(ll i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++){ st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); } } while(m --){ ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; Query(l, r) &lt;&lt; \"\\n\"; } return 0;} 更多思考 为什么 ST表 似乎很少被用于区间求和之类的问题？ 这个问题看起来很傻，却很有用。大概有如下两个原因： 可以用前缀和，更好写还不容易错 ST表如果想要O(1)查询，需要满足所求的问题区间能够重复覆盖。因为查询是两边重叠算的啊 显然，对于第二点，区间求和并不满足条件（如果重复覆盖就会有许多值被加了多次）。那么可不可以进行二进制拆分呢？答案显然是可以的。","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"}]},{"title":"Floyd 全源最短路径算法笔记","slug":"Floyd Path","date":"2024-10-12T16:00:00.000Z","updated":"2025-03-25T14:24:34.130Z","comments":true,"path":"2024/10/13/Floyd Path/","permalink":"https://allen2010.github.io/2024/10/13/Floyd%20Path/","excerpt":"多源最短路径最简单、最实用、最好理解，同时也是最慢的经典算法。","text":"算法描述 三个破变量，一共就十行。编程十分钟，运行一晚上。 很多人认为 Floyd 就是简单的动态规划，甚至有人直接把它当模板背了下来，导致不会变通而 WA 了 P1119。然而其实大多数初学者包括我一开始都理解错了它，包括原理。 算法实现定义 表示只包含前 个节点时 到 的最短路。而加不加入这个 号元素前后有什么区别呢？无非就是某两个点的最短路通过 号点松弛出了更有的最短路嘛。于是就有了经典代码：123456789void Floyd(){ for(ll k = 1; k &lt;= n; k ++){ for(ll i = 1; i &lt;= n; i ++){ for(ll j = 1; j &lt;= n; j ++){ dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } }}那么如何初始化呢？如果 到 有路，就初始化为边长。否则初始化为最大值。1234567for(ll i = 1; i &lt;= n; i ++){ for(ll j = 1; j &lt;= n; j ++){ if(i == j)dis[i][j] = 0; else if(gph[i][j])dis[i][j] = gph[i][j]; else dis[i][j] = INF; }}这就完了吗？这值得写博客吗？当然不值。虽然我本来就是给自己写来复习的 Floyd应用Floyd解决传递闭包问题题目传送门 在有向图中，定义 如果是 1，则表示 能到达 ，否则反之。 这该如何解决呢？转换一下定义。定义 表示只有前 个点时 能否到达 。同理，加入了一个元素 之后无非就是有一组 能通过它到达 了。 123456789101112131415161718192021void Floyd(){ for(ll i = 1; i &lt;= n; i ++){ for(ll j = 1; j &lt;= n; j ++){ if(graph[i][j])d[i][j] = 1; else d[i][j] = 0; } } for(ll k = 1; k &lt;= n; k ++){ for(ll i = 1; i &lt;= n; i ++){ for(ll j = 1; j &lt;= n; j ++){ d[i][j] = d[i][j] || (d[i][k] &amp;&amp; d[k][j]); } } } for(ll i = 1; i &lt;= n; i ++){ for(ll j = 1; j &lt;= n; j ++){ cout &lt;&lt; d[i][j] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; }} Floyd求最小环依旧是改定义： 为前 个节点中可以确定的最小环的大小。则匹配最短路，可以在算最短路之后算环了，可以理解为以 为一个顶点，由 可以到达的 和 以及 也就是最短路构成的环。然后枚举已经算出最短路的 即可。例题就是 P2738 篱笆回路。这题输入特别逆天，所以给了完整代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const ll MAXN = 305;const ll INF = 2147483647;struct Edge{ ll u, v, w; bool lside[MAXN], rside[MAXN];}edge[MAXN]; ll adj[MAXN][MAXN], father[MAXN], m, n, idx[MAXN], dis[MAXN][MAXN];ll find(ll x){ if(father[x] == x)return x; return father[x] = find(father[x]);}void merge(ll x, ll y){ father[find(x)] = find(y);}ll Floyd(){ ll ans = INF; for(ll i = 1; i &lt;= n; i ++){ for(ll j = 1; j &lt;= n; j ++){ if(!dis[i][j])dis[i][j] = INF; if(!adj[i][j])adj[i][j] = INF; } } for(ll i = 1; i &lt;= n; i ++){ adj[i][i] = dis[i][i] = 0; } for(ll k = 1; k &lt;= n; k ++){ for(ll i = 1; i &lt;= k - 1; i ++){ for(ll j = i + 1; j &lt;= k - 1; j ++){ ans = min(ans, adj[i][k] + adj[k][j] + dis[i][j]); } } for(ll i = 1; i &lt;= n; i ++){ for(ll j = 1; j &lt;= n; j ++){ dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } return ans;}int main(){ cin &gt;&gt; m; for(ll i = 1; i &lt;= m; i ++){ ll s, len, numl, numr, id; cin &gt;&gt; s &gt;&gt; len &gt;&gt; numl &gt;&gt; numr; edge[s].u = s * 2 - 1; edge[s].v = s * 2; edge[s].w = len; for(ll j = 1; j &lt;= numl; j ++){ cin &gt;&gt; id; edge[s].lside[id] = 1; } for(ll j = 1; j &lt;= numr; j ++){ cin &gt;&gt; id; edge[s].rside[id] = 1; } } for(ll i = 1; i &lt;= 250; i ++){ father[i] = i; } for(ll i = 1; i &lt;= m; i ++){ for(ll j = 1; j &lt;= m; j ++){ if(i == j)continue; if(edge[i].lside[j] &amp;&amp; edge[j].lside[i]){ merge(edge[i].u, edge[j].u); } if(edge[i].lside[j] &amp;&amp; edge[j].rside[i]){ merge(edge[i].u, edge[j].v); } if(edge[i].rside[j] &amp;&amp; edge[j].lside[i]){ merge(edge[i].v, edge[j].u); } if(edge[i].rside[j] &amp;&amp; edge[j].rside[i]){ merge(edge[i].v, edge[j].v); } } } for(ll i = 1; i &lt;= 2 * m; i ++){ if(father[i] == i){ idx[i] = ++n; } } for(ll i = 1; i &lt;= m; i ++){ edge[i].u = idx[find(edge[i].u)]; edge[i].v = idx[find(edge[i].v)]; adj[edge[i].u][edge[i].v] = edge[i].w; adj[edge[i].v][edge[i].u] = edge[i].w; dis[edge[i].u][edge[i].v] = edge[i].w; dis[edge[i].v][edge[i].u] = edge[i].w; } cout &lt;&lt; Floyd() &lt;&lt; \"\\n\"; return 0;} 总结Floyd 算法似乎从方方面面看都很平庸：时间复杂度高达 ，需要空间复杂度耗费较大的邻接矩阵存图，甚至连模板的使用环境都比较小。然而 Floyd 算法具有较高的灵活性、可读性和可写性。一旦深刻理解了它的原理，就可以加以变通，解决许许多多看似复杂的算法。以上就是例子，希望大家不要想我最初一样，只背了模板，没有思考含义。 Floyd 算法之所以被发明出来，并不是因为他比 Dijkstra 更快，比 SPFA 更好理解，而是因为，他善啊…… 推荐例题：洛谷 P1119 灾后重建，P1841 重要的城市","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"shortest path","slug":"shortest-path","permalink":"https://allen2010.github.io/tags/shortest-path/"}]}],"categories":[{"name":"Works","slug":"Works","permalink":"https://allen2010.github.io/categories/Works/"},{"name":"Favourite","slug":"Favourite","permalink":"https://allen2010.github.io/categories/Favourite/"},{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"},{"name":"Theme","slug":"Theme","permalink":"https://allen2010.github.io/categories/Theme/"}],"tags":[{"name":"sketch","slug":"sketch","permalink":"https://allen2010.github.io/tags/sketch/"},{"name":"design","slug":"design","permalink":"https://allen2010.github.io/tags/design/"},{"name":"badminton","slug":"badminton","permalink":"https://allen2010.github.io/tags/badminton/"},{"name":"personal thought","slug":"personal-thought","permalink":"https://allen2010.github.io/tags/personal-thought/"},{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"divide & conquer","slug":"divide-conquer","permalink":"https://allen2010.github.io/tags/divide-conquer/"},{"name":"Hexo","slug":"Hexo","permalink":"https://allen2010.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://allen2010.github.io/tags/Theme/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"},{"name":"shortest path","slug":"shortest-path","permalink":"https://allen2010.github.io/tags/shortest-path/"}]}