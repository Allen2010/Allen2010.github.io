{"meta":{"title":"Allen2010 Blog","subtitle":"Explore Here!","description":"BlackBasalt","author":"Allenyang","url":"https://allen2010.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2021-01-25T14:37:25.000Z","updated":"2025-03-16T00:12:10.637Z","comments":true,"path":"categories/index.html","permalink":"https://allen2010.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-02-26T13:36:12.282Z","updated":"2025-02-26T13:36:12.282Z","comments":true,"path":"css/custom.css","permalink":"https://allen2010.github.io/css/custom.css","excerpt":"","text":"@font-face { /* 为载入的字体取名字(随意) */ font-family: 'LXGWWenKai-Regular'; /* 字体文件地址(相对或者绝对路径都可以) */ src: url(fonts/TTF/LXGWWenKai-Regular.ttf); /* 定义加粗样式(加粗多少) */ font-weight: normal; /* 定义字体样式(斜体/非斜体) */ font-style: normal; /* 定义显示样式 */ font-display: block; }"},{"title":"About","date":"2025-03-21T13:33:01.000Z","updated":"2025-03-21T14:11:24.491Z","comments":true,"path":"about/index.html","permalink":"https://allen2010.github.io/about/index.html","excerpt":"","text":"About Me I’m Allen2010, as known as “Allen_yang” in Luogu, a Chinese 8th grade students. 大家好，这里是 Allen2010 的博客。我是一名中国北京市初二学生，在洛谷账号为 Allen_yang(uid:683768)。一名很菜的 OIer，低端的小说家和落魄的理科生。虽打着信息学竞赛生的名号，却主攻文化课。擅长数学，物理略好，其他的中等偏上。主要爱好目前有： 写小说，以奇幻、冒险或其他非传统网络小说为主题 学算法，写代码，顺便发表算法笔记 打 Atcoder 和 Luogu 比赛 设计建筑，重要应用 Sketch Up 草图大师 自然风光，例如 热带稀树草原 温带疏林草原 热带雨林 海滩 海洋性气候雪景 打羽球（反正你也看不到） Blog Topic我将在这个博客上发表一些自己原创的文章，分类的介绍如下 Note 算法笔记学习算法后的感悟、总结以及对算法实现的见解 Works 建模渲染作品、画作建模作品的渲染图、作品介绍以及理念。建筑设计为主。 Essay 随笔随笔。 Novel 小说个人爱好，文笔不佳。以奇幻、冒险等元素构成的小说（也可能是片段），风格新奇。 Personal Experience个人经历，未完成。 信息学初中羽毛球小说建筑设计爱好History本博客搭建于 2024 年，应用于 2025 年。经历从 volantis 到 NexT 主题的转变，我的审美和风格发生了很大转变。现在，文笔将以简洁明了为主，去除骈文式的繁杂语句和自创揉词awa。"},{"title":"标签","date":"2021-01-25T14:54:58.000Z","updated":"2025-03-16T00:11:06.974Z","comments":true,"path":"tags/index.html","permalink":"https://allen2010.github.io/tags/index.html","excerpt":"","text":""},{"title":"FRIENDS","date":"2025-01-27T04:21:54.497Z","updated":"2025-01-27T04:21:54.497Z","comments":true,"path":"friends/index.html","permalink":"https://allen2010.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Segment Tree 线段树笔记","slug":"Segment Tree","date":"2025-03-21T16:00:00.000Z","updated":"2025-03-25T09:11:58.290Z","comments":true,"path":"2025/03/22/Segment Tree/","permalink":"https://allen2010.github.io/2025/03/22/Segment%20Tree/","excerpt":"区间求和与最值等区间问题在算法竞赛中扮演着重要的一环。而其中伴随的区间修改，便需要用线段树来解决。","text":"算法描述 线段树常用于解决区间修改查询问题，包括但不限于最大值、最小值和求和。线段树最大的难点，就是你不知道它将用来解决怎样的问题。 定义线段树就是一棵普普通通的树，它的大部分节点都有两个子节点，但并不是一棵满二叉树，也不是完全二叉树。这一点你在学习后面的文章后就会明白了。线段树上每一个节点都代表着一段区间，而每个子结点代表的区间长度都是其父节点的一半。若长度是奇数则会有些许偏差。而节点的值则是这个区间的需求。 应用线段树可以解决大部分的区间问题，只要你能想清楚怎么分治，基本上就是线段树没得跑。哪怕这个区间的需求是连续的。通常来说，线段树的操作分为以下几种： 建树：输入数组并建立对应需求的线段树 单点修改：将 $x$ 位置的元素改成 $v$ 区间修改：将 $l$ 到 $r$ 位置的所用元素改成或增加 $v$ 区间查询：查询 $l$ 到 $r$ 区间内的最大/最小/和/其他需求 算法实现线段树用数组实现。注意数组大小要开到 $4 \\times n$。左右子树的编号分别是 $i \\times 2$ 和 $i \\times 2 + 1$。12ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125; 初始化从根节点开始，不断的分割区间直到该区间只剩单个数，然后开始向上汇总。传入两个变量 l 和 r， 表示当前节点表示的线段。1234567891011121314void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125; 区间查询从根节点开始，如果当前的线段不被查询的区间完全包含就一直分两段尝试，直到它被完全包含了，返回该线段的值然后继续递归其他的。1234567891011121314ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125; 区间修改如果每次修改都从上到下全改一遍，复杂度得 $\\mathcal{O}(n)$ ，太浪费时间了，完全体现不出线段树的优势所在。因此引入懒标记（Lazy Tag）。和查询一样，当线段被区间完全覆盖时，对应的节点自己更新，但它的孩子们不更新。这时给他安上一个懒标记，表示它的子节点需要更新的大小。当区间没有完全覆盖，需要拆分的时候，将当前变量的标记拆掉，传给子节点，这样才不会错算。12345678910111213141516void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125; 例题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 5;ll segt[4 * MAXN], tag[4 * MAXN], a[MAXN];ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125;void pushUp(ll p)&#123; segt[p] = min(segt[lc(p)], segt[rc(p)]);&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; segt[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p);&#125;void moveTag(ll p, ll k)&#123; tag[p] += k; segt[p] += k;&#125;void pushDown(ll p)&#123; moveTag(lc(p), tag[p]); moveTag(rc(p), tag[p]); tag[p] = 0;&#125;void Update(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; moveTag(p, 1); return; &#125; pushDown(p); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)Update(lc(p), l, mid, ql, qr); if(qr &gt; mid)Update(rc(p), mid + 1, r, ql, qr); pushUp(p);&#125;ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return segt[p]; &#125; pushDown(p); ll mid = (l + r) &gt;&gt; 1, ans = 2147483647; if(ql &lt;= mid)ans = min(ans, Query(lc(p), l, mid, ql, qr)); if(qr &gt; mid)ans = min(ans, Query(rc(p), mid + 1, r, ql, qr)); return ans;&#125;int main()&#123; ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); while(m --)&#123; ll opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if(opt == 1)&#123; Update(1, 1, n, l, r); &#125;else&#123; cout &lt;&lt; Query(1, 1, n, l, r) &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125; 变种区间和并线段树在遇到有区间连续的需求时，我们发现传统线段树并不适用，因为分段时无法控制答案的范围，在向上整理回父节点时可能会遇到答案的中间部分没有连接但却错误转移的情况。我们可以定义额外的变量存于线段树的数组，分别表示了以区间最左边和最右边起始的答案，这样就只需要思考如何 pushUp 转移了。 例题 输入一个长度为 $n$ 的数组 $a$，数组的元素均为整数且满足 $-4000 \\leq a_i \\leq 4000$。对该数组可以发出 $m$ 条指令。指令共有 $2$ 种： 1 x v，该指令将 $a_x$ 的值修改为 $v$ 2 l r，该指令查询区间 $l$ 到 $r$ 的最大连续子序列和，即区间所有可能的连续子序列中求和的最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;typedef long long ll;const ll MAXN = 400005, fINF = LONG_LONG_MIN;struct Node&#123; ll sum = 0, lans = fINF, rans = fINF, ans = fINF;&#125;segt[4 * MAXN];ll a[MAXN];ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125;void pushUp(ll p)&#123; segt[p].sum = segt[lc(p)].sum + segt[rc(p)].sum; segt[p].lans = max(&#123;segt[lc(p)].sum + segt[rc(p)].lans, segt[lc(p)].lans&#125;); segt[p].rans = max(&#123;segt[rc(p)].sum + segt[lc(p)].rans, segt[rc(p)].rans&#125;); segt[p].ans = max(&#123;segt[lc(p)].rans + segt[rc(p)].lans, segt[lc(p)].ans, segt[rc(p)].ans&#125;);&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; segt[p].ans = segt[p].lans = segt[p].rans = segt[p].sum = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p);&#125;void Update(ll p, ll l, ll r, ll x, ll v)&#123; if(l == r)&#123; segt[p].sum = segt[p].ans = segt[p].lans = segt[p].rans = v; return; &#125; ll mid = (l + r) &gt;&gt; 1; if(x &lt;= mid)Update(lc(p), l, mid, x, v); else if(x &gt; mid)Update(rc(p), mid + 1, r, x, v); pushUp(p);&#125;Node Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return segt[p]; &#125; ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid &amp;&amp; qr &gt; mid)&#123; Node ans, qla = Query(lc(p), l, mid, ql, qr), qra = Query(rc(p), mid + 1, r, ql, qr); ans.sum = qla.sum + qra.sum; ans.ans = max(&#123;ans.ans, qla.ans, qra.ans, qla.rans + qra.lans&#125;); ans.lans = max(&#123;ans.lans, qla.lans, qla.sum + qra.lans&#125;); ans.rans = max(&#123;ans.rans, qra.rans, qra.sum + qla.rans&#125;); return ans; &#125;else if(ql &lt;= mid)&#123; return Query(lc(p), l, mid, ql, qr); &#125;else&#123; return Query(rc(p), mid + 1, r, ql, qr); &#125;&#125;int main()&#123; ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); while(m --)&#123; ll opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if(opt == 1)&#123; Update(1, 1, n, l, r); &#125;else&#123; cout &lt;&lt; Query(1, 1, n, l, r).ans &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125; 总结极为常用，需要会用、会推、会写且达到熟练的地步。复杂度 $\\mathcal{O(log_2 n)}$，已经很快了。","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"divide & conquer","slug":"divide-conquer","permalink":"https://allen2010.github.io/tags/divide-conquer/"}]},{"title":"LCA 最近共同祖先算法笔记","slug":"Lowest Common Ancestor","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-25T09:08:46.574Z","comments":true,"path":"2025/03/02/Lowest Common Ancestor/","permalink":"https://allen2010.github.io/2025/03/02/Lowest%20Common%20Ancestor/","excerpt":"对于一棵树上任意两个节点的最近共同祖先问题，能否用倍增法解决？","text":"算法描述 恐龙，是指三角龙、现代鸟类和梁龙的最近共同祖先 (LCA) 及其所有后代。 ——百度百科 假设有一棵树，上面有两个节点，求两个节点最近的共同祖先节点。也可以理解为包含这两个节点的子树是从什么时候分开的。 算法思路 一生二，二生四，四生万物。 ——泥土笨笨 采用倍增的思想，将查询最近共同祖先问题分成若干部： 预处理预处理一个数组 anc[i][j] 表示 $i$ 节点的 $2^j$ 号祖先的编号。其中有 anc[i][j] = anc[anc[i][j - 1]][j - 1]; 意思是 $i$ 的 $2^j$ 祖先就是 $i$ 的 $2^{j-1}$ 的祖先的 $2^{j-1}$ 祖先。通过这个式子就可以转移了。转移过程中同时预处理 $dep[i]$ 数组表示深度，后面会用到。123456789101112void dfs(ll u, ll father)&#123; //该节点和它的父亲节点 dep[u] = dep[father] + 1; //预处理深度 anc[u][0] = father; //i 的 第一个祖先，即父亲。 for(ll i = 1; (1 &lt;&lt; i) &lt;= dep[u]; i ++)&#123; anc[u][i] = anc[anc[u][i - 1]][i - 1]; //转移，由于是从小到大枚举的j，所以当前的anc转移一定是正确的 &#125; for(ll i = head[u]; i; i = pool[i].next)&#123; //往下递归 if(pool[i].v != father)&#123; dfs(pool[i].v, u); &#125; &#125;&#125; 调整深度追平深度。顾名思义，通过不断调整深度让需要查询的两个节点深度相等。123456if(dep[x] &lt; dep[y])&#123; swap(x, y);&#125;while(dep[x] &gt; dep[y])&#123; x = anc[x][lg[dep[x] - dep[y]] - 1];&#125; 跳跃结算一起往上调，跳的步数从 $2^{dep_x}$ 步开始不断尝试，如果调完了发现重合，就放弃，然后尝试少跳一点，以此类推。直到最后到达了最接近共同祖先的位置，即共同祖先的孩子节点。为什么重合要放弃？因为谁也没办法保证当前的重合点是最近的，要不断尝试下调就太麻烦了。12345678if(x == y)return x;for(ll i = lg[dep[x]]; i &gt;= 0; i --)&#123; if(anc[x][i] != anc[y][i])&#123; x = anc[x][i]; y = anc[y][i]; &#125;&#125;return anc[x][0]; 总代码例题：洛谷 P3379【模板】最近公共祖先（LCA）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const ll MAXN = 500005;struct Node&#123; ll v, next;&#125;pool[2 * MAXN];ll anc[MAXN][25], dep[MAXN], head[MAXN], nn, lg[MAXN];ll n, m, s;void addEdge(ll u, ll v)&#123; pool[++nn].v = v; pool[nn].next = head[u]; head[u] = nn;&#125;void dfs(ll u, ll father)&#123; dep[u] = dep[father] + 1; anc[u][0] = father; for(ll i = 1; (1 &lt;&lt; i) &lt;= dep[u]; i ++)&#123; anc[u][i] = anc[anc[u][i - 1]][i - 1]; &#125; for(ll i = head[u]; i; i = pool[i].next)&#123; if(pool[i].v != father)&#123; dfs(pool[i].v, u); &#125; &#125;&#125;ll lca(ll x, ll y)&#123; if(dep[x] &lt; dep[y])&#123; swap(x, y); &#125; while(dep[x] &gt; dep[y])&#123; x = anc[x][lg[dep[x] - dep[y]] - 1]; &#125; if(x == y)return x; for(ll i = lg[dep[x]]; i &gt;= 0; i --)&#123; if(anc[x][i] != anc[y][i])&#123; x = anc[x][i]; y = anc[y][i]; &#125; &#125; return anc[x][0];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for(ll i = 1; i &lt;= n - 1; i ++)&#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; addEdge(x, y); addEdge(y, x); &#125; for(ll i = 1; i &lt;= n; i ++)&#123; lg[i] = lg[i - 1] + ((1 &lt;&lt; lg[i - 1]) == i); &#125; dfs(s, 0); for(ll i = 1; i &lt;= m; i ++)&#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(x, y) &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"}]},{"title":"Sparse Table ST表笔记","slug":"Sparse Table","date":"2025-02-21T16:00:00.000Z","updated":"2025-03-25T09:09:26.033Z","comments":true,"path":"2025/02/22/Sparse Table/","permalink":"https://allen2010.github.io/2025/02/22/Sparse%20Table/","excerpt":"区间贡献问题的另一种更简单、更快捷的解决方案。","text":"问题叙述 RMQ 是 Range Maximum/Minimum Query 的缩写，表示可重复贡献的区间最大/最小值。 显而易见的，可以用线段树实现。但是由于该问题不涉及修改操作，且线段树太长了不好写，十分浪费时间。 这是就需要用到好理解又好写的ST表了。 算法思路 ST表(Sparse Table)是用于解决可重复贡献问题的数据结构。 倍增思想：我们考虑将 $st_{i,j}$ 定义为 起点为 $i$, 到 $i + 2^j - 1$ 位置的所有元素的最大值。例如 $st_{i,1}$ 表示 $i$ 和 $i + 1$ 中的最大值。 转移过程把当前区间拆成两个大小相等的区间，用动态规划求出答案。 st_{i,j} = max(st_{i,j - 1},st_{i + 2^{j-1},j - 1})这样就可以保证该区间内所有的元素都被转移了。预处理就是将 $st_{i,0}$ 表示第 $i$ 个元素的最大值，即本身。 查询过程查询过程也一样，分成两个区间，这里我用的是 $st_{i,k}$ 和 $st_{r-2^k+1,k}$，因为这样刚好有一部分重叠，可以保证答案转移的正确性，然后分别求最大值最后在汇总一下。 max(st_{l,k}, st_{r - 2^k + 1,k})其中的 k = log[r - l + 1]，用于分隔两个区间。至于怎么求 $\\log$，这里我用的是传统求 lg[i] + 1 的写法，见下方代码。 总代码例题：洛谷 P3865【模板】ST 表 &amp;&amp; RMQ 问题12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const ll MAXN = 1e5 + 5;ll st[MAXN][25], lg[MAXN];ll Query(ll l, ll r)&#123; ll k = lg[r - l + 1] - 1; return max(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; st[i][0]; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; lg[i] = lg[i - 1] + ((1 &lt;&lt; lg[i - 1]) == i); &#125; for(ll j = 1; j &lt;= 20; j ++)&#123; for(ll i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++)&#123; st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; while(m --)&#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; Query(l, r) &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 更多思考 为什么 ST表 似乎很少被用于区间求和之类的问题？ 这个问题看起来很傻，却很有用。大概有如下两个原因： 可以用前缀和，更好写还不容易错 ST表如果想要O(1)查询，需要满足所求的问题区间能够重复覆盖。因为查询是两边重叠算的啊 显然，对于第二点，区间求和并不满足条件（如果重复覆盖就会有许多值被加了多次）。那么可不可以进行二进制拆分呢？答案显然是可以的。","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"}]},{"title":"Floyd 全源最短路径算法笔记","slug":"Floyd Path","date":"2024-10-12T16:00:00.000Z","updated":"2025-03-25T09:09:04.281Z","comments":true,"path":"2024/10/13/Floyd Path/","permalink":"https://allen2010.github.io/2024/10/13/Floyd%20Path/","excerpt":"多源最短路径最简单、最实用、最好理解，同时也是最慢的经典算法。","text":"算法描述 三个破变量，一共就十行。编程十分钟，运行一晚上。 很多人认为 Floyd 就是简单的动态规划，甚至有人直接把它当模板背了下来，导致不会变通而 WA 了 P1119。然而其实大多数初学者包括我一开始都理解错了它，包括原理。 算法实现定义 $dis_{i,j}^k$ 表示只包含前 $k$ 个节点时 $i$ 到 $j$ 的最短路。而加不加入这个 $k$ 号元素前后有什么区别呢？无非就是某两个点的最短路通过 $k$ 号点松弛出了更有的最短路嘛。于是就有了经典代码：123456789void Floyd()&#123; for(ll k = 1; k &lt;= n; k ++)&#123; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;&#125;那么如何初始化呢？如果 $i$ 到 $j$ 有路，就初始化为边长。否则初始化为最大值。1234567for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; if(i == j)dis[i][j] = 0; else if(gph[i][j])dis[i][j] = gph[i][j]; else dis[i][j] = INF; &#125;&#125;这就完了吗？这值得写博客吗？当然不值。虽然我本来就是给自己写来复习的 Floyd应用Floyd解决传递闭包问题题目传送门 在有向图中，定义 $d_{i,j}$ 如果是 1，则表示 $i$ 能到达 $j$，否则反之。 这该如何解决呢？转换一下定义。定义 $d_{i,j}^k$ 表示只有前 $k$ 个点时 $i$ 能否到达 $j$。同理，加入了一个元素 $k$ 之后无非就是有一组 $i$ 能通过它到达 $j$ 了。 123456789101112131415161718192021void Floyd()&#123; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; if(graph[i][j])d[i][j] = 1; else d[i][j] = 0; &#125; &#125; for(ll k = 1; k &lt;= n; k ++)&#123; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; d[i][j] = d[i][j] || (d[i][k] &amp;&amp; d[k][j]); &#125; &#125; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; cout &lt;&lt; d[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125; Floyd求最小环依旧是改定义：$d_{i,j}^k$ 为前 $k$ 个节点中可以确定的最小环的大小。则匹配最短路，可以在算最短路之后算环了，可以理解为以 $k$ 为一个顶点，由 $k$ 可以到达的 $i$ 和 $j$ 以及 $dis_{i,j}$ 也就是最短路构成的环。然后枚举已经算出最短路的 $i,j$ 即可。例题就是 P2738 篱笆回路。这题输入特别逆天，所以给了完整代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const ll MAXN = 305;const ll INF = 2147483647;struct Edge&#123; ll u, v, w; bool lside[MAXN], rside[MAXN];&#125;edge[MAXN]; ll adj[MAXN][MAXN], father[MAXN], m, n, idx[MAXN], dis[MAXN][MAXN];ll find(ll x)&#123; if(father[x] == x)return x; return father[x] = find(father[x]);&#125;void merge(ll x, ll y)&#123; father[find(x)] = find(y);&#125;ll Floyd()&#123; ll ans = INF; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; if(!dis[i][j])dis[i][j] = INF; if(!adj[i][j])adj[i][j] = INF; &#125; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; adj[i][i] = dis[i][i] = 0; &#125; for(ll k = 1; k &lt;= n; k ++)&#123; for(ll i = 1; i &lt;= k - 1; i ++)&#123; for(ll j = i + 1; j &lt;= k - 1; j ++)&#123; ans = min(ans, adj[i][k] + adj[k][j] + dis[i][j]); &#125; &#125; for(ll i = 1; i &lt;= n; i ++)&#123; for(ll j = 1; j &lt;= n; j ++)&#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; m; for(ll i = 1; i &lt;= m; i ++)&#123; ll s, len, numl, numr, id; cin &gt;&gt; s &gt;&gt; len &gt;&gt; numl &gt;&gt; numr; edge[s].u = s * 2 - 1; edge[s].v = s * 2; edge[s].w = len; for(ll j = 1; j &lt;= numl; j ++)&#123; cin &gt;&gt; id; edge[s].lside[id] = 1; &#125; for(ll j = 1; j &lt;= numr; j ++)&#123; cin &gt;&gt; id; edge[s].rside[id] = 1; &#125; &#125; for(ll i = 1; i &lt;= 250; i ++)&#123; father[i] = i; &#125; for(ll i = 1; i &lt;= m; i ++)&#123; for(ll j = 1; j &lt;= m; j ++)&#123; if(i == j)continue; if(edge[i].lside[j] &amp;&amp; edge[j].lside[i])&#123; merge(edge[i].u, edge[j].u); &#125; if(edge[i].lside[j] &amp;&amp; edge[j].rside[i])&#123; merge(edge[i].u, edge[j].v); &#125; if(edge[i].rside[j] &amp;&amp; edge[j].lside[i])&#123; merge(edge[i].v, edge[j].u); &#125; if(edge[i].rside[j] &amp;&amp; edge[j].rside[i])&#123; merge(edge[i].v, edge[j].v); &#125; &#125; &#125; for(ll i = 1; i &lt;= 2 * m; i ++)&#123; if(father[i] == i)&#123; idx[i] = ++n; &#125; &#125; for(ll i = 1; i &lt;= m; i ++)&#123; edge[i].u = idx[find(edge[i].u)]; edge[i].v = idx[find(edge[i].v)]; adj[edge[i].u][edge[i].v] = edge[i].w; adj[edge[i].v][edge[i].u] = edge[i].w; dis[edge[i].u][edge[i].v] = edge[i].w; dis[edge[i].v][edge[i].u] = edge[i].w; &#125; cout &lt;&lt; Floyd() &lt;&lt; &quot;\\n&quot;; return 0;&#125; 总结Floyd 算法似乎从方方面面看都很平庸：时间复杂度高达 $\\mathcal{O}(n^3)$，需要空间复杂度耗费较大的邻接矩阵存图，甚至连模板的使用环境都比较小。然而 Floyd 算法具有较高的灵活性、可读性和可写性。一旦深刻理解了它的原理，就可以加以变通，解决许许多多看似复杂的算法。以上就是例子，希望大家不要想我最初一样，只背了模板，没有思考含义。 Floyd 算法之所以被发明出来，并不是因为他比 Dijkstra 更快，比 SPFA 更好理解，而是因为，他善啊…… 推荐例题：洛谷 P1119 灾后重建，P1841 重要的城市","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"shortest path","slug":"shortest-path","permalink":"https://allen2010.github.io/tags/shortest-path/"}]}],"categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"divide & conquer","slug":"divide-conquer","permalink":"https://allen2010.github.io/tags/divide-conquer/"},{"name":"binary lifting","slug":"binary-lifting","permalink":"https://allen2010.github.io/tags/binary-lifting/"},{"name":"shortest path","slug":"shortest-path","permalink":"https://allen2010.github.io/tags/shortest-path/"}]}