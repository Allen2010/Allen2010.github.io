{"meta":{"title":"Allen2010 Blog","subtitle":"Explore Here!","description":"aaaa","author":"Allen-yang","url":"https://allen2010.github.io","root":"/"},"pages":[{"title":"","date":"2025-01-27T05:01:59.783Z","updated":"2025-01-27T05:01:59.783Z","comments":true,"path":"about/index.html","permalink":"https://allen2010.github.io/about/index.html","excerpt":"","text":"2010年的北京OIer，现初二，喜欢看一些奇幻小说，例如 Lord of the Rings 和 A Song of Ice and Fire。有时自己也会尝试写一些片段，但是文笔不甚佳QwQ"},{"title":"CATEGORY","date":"2025-01-27T10:09:42.000Z","updated":"2025-01-27T04:53:38.741Z","comments":true,"path":"categories/index.html","permalink":"https://allen2010.github.io/categories/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2022-06-08T10:10:12.000Z","updated":"2025-01-26T23:44:45.801Z","comments":true,"path":"tags/index.html","permalink":"https://allen2010.github.io/tags/index.html","excerpt":"","text":""},{"title":"FRIENDS","date":"2025-01-27T04:21:54.497Z","updated":"2025-01-27T04:21:54.497Z","comments":true,"path":"friends/index.html","permalink":"https://allen2010.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Excerpt 片段","slug":"excerpt1","date":"2025-01-26T16:00:00.000Z","updated":"2025-01-27T07:38:33.858Z","comments":true,"path":"2025/01/27/excerpt1/","permalink":"https://allen2010.github.io/2025/01/27/excerpt1/","excerpt":"","text":"Excerpt 1 海陆之间Lgy 在海滨有一个临时住所。每当如此时此刻他无处可去时，就会来到这个能暂时保他一命的地方。庇护所隐藏在海边的丛林中，似乎很难找到。跟随这 Lgy 的步伐， Jcy 也来到了这里，他明白过来庇护所也就是用从林木搭建的临时仓库。","categories":[{"name":"Essay","slug":"Essay","permalink":"https://allen2010.github.io/categories/Essay/"}],"tags":[{"name":"excerpt","slug":"excerpt","permalink":"https://allen2010.github.io/tags/excerpt/"}]},{"title":"Segment Tree 线段树笔记","slug":"SegT","date":"2025-01-26T16:00:00.000Z","updated":"2025-01-27T07:48:54.857Z","comments":true,"path":"2025/01/27/SegT/","permalink":"https://allen2010.github.io/2025/01/27/SegT/","excerpt":"","text":"算法描述 线段树是一种能够处理区间修改和区间查询的数据结构。 顾名思义，线段树就是一种存储着线段数据的树形结构。它的每个节点都表示一个线段区间，每个节点的孩子节点存储的就是该区间的左半段和右半段。每个线段区间都存储着一个值，一般是区间和，也有可能是区间最大&#x2F;最小值。 算法实现线段树使用数组实现，根节点编号为 $1$ 表示区间 $1$ 到 $n$，左子节点是 $i \\times 2$，右子节点是 $i \\times 2 + 1$. 12ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125; 初始化从根节点开始，不断的分割区间直到该区间只剩单个数，然后开始向上汇总。传入两个变量 l 和 r， 表示当前节点表示的线段。 1234567891011121314void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125; 区间查询从根节点开始，如果当前的线段不被查询的区间完全包含就一直分两段尝试，直到它被完全包含了，返回该线段的值然后继续递归其他的。 1234567891011121314ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125; 区间修改如果每次修改都从上到下全改一遍，复杂度得 $\\mathcal{O}(n)$ ，太浪费时间了，完全体现不出线段树的优势所在。因此引入懒标记（Lazy Tag）。和查询一样，当线段被区间完全覆盖时，对应的节点自己更新，但它的孩子们不更新。这时给他安上一个懒标记，表示它的子节点需要更新的大小。当区间没有完全覆盖，需要拆分的时候，将当前变量的标记拆掉，传给子节点，这样才不会错算。 12345678910111213141516void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125; 复杂度估算由于线段树原理是每个区间分两段，再将两端区间分别分段以此类推，又有 $n$ 个元素，因此线段树的高度是 $\\log n$ 的。而区间修改和查询最坏都要遍历一遍每一层，因此修改和查询的复杂度都是 $\\mathcal{O}\\log n$ 的，足以应付大部分题目。 总代码题目：洛谷 P3372【模板】线段树 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const ll MAXN = 1e5 + 5;ll sum[4 * MAXN], a[MAXN], tag[4 * MAXN];ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125;void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125;void moveTag(ll p, ll l, ll r, ll t)&#123; sum[p] += t * (r - l + 1); tag[p] += t;&#125;void pushDown(ll p, ll l, ll r)&#123; ll mid = (l + r) &gt;&gt; 1; moveTag(lc(p), l, mid, tag[p]); moveTag(rc(p), mid + 1, r, tag[p]); tag[p] = 0;&#125;void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125;ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); while(m --)&#123; ll o, x, y, k; cin &gt;&gt; o; if(o == 1)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; Update(1, 1, n, x, y, k); &#125;else&#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; Query(1, 1, n, x, y) &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"}]},{"title":"First BLog","slug":"First-Blog","date":"2025-01-25T16:00:00.000Z","updated":"2025-01-27T04:59:45.344Z","comments":true,"path":"2025/01/26/First-Blog/","permalink":"https://allen2010.github.io/2025/01/26/First-Blog/","excerpt":"","text":"First Blog这是我的第一篇博客，以此纪念经历一周方才搭建成功的博客。","categories":[{"name":"Unknown","slug":"Unknown","permalink":"https://allen2010.github.io/categories/Unknown/"}],"tags":[{"name":"memento","slug":"memento","permalink":"https://allen2010.github.io/tags/memento/"}]}],"categories":[{"name":"Essay","slug":"Essay","permalink":"https://allen2010.github.io/categories/Essay/"},{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"},{"name":"Unknown","slug":"Unknown","permalink":"https://allen2010.github.io/categories/Unknown/"}],"tags":[{"name":"excerpt","slug":"excerpt","permalink":"https://allen2010.github.io/tags/excerpt/"},{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"memento","slug":"memento","permalink":"https://allen2010.github.io/tags/memento/"}]}