{"meta":{"title":"Allen2010 Blog","subtitle":"Explore Here!","description":"aaaa","author":"Allen-yang","url":"https://allen2010.github.io","root":"/"},"pages":[{"title":"","date":"2025-01-27T10:19:59.884Z","updated":"2025-01-27T10:19:59.884Z","comments":true,"path":"about/index.html","permalink":"https://allen2010.github.io/about/index.html","excerpt":"","text":"个人资料 出生年份：2010年北京 爱好：编程、写小说片段 基本资料： 初二 Luogu OIer，没什么水平，爱好算法。喜欢诸如 The Lord of the Rings 和 A Song of Ice and Fire 之类的奇幻小说。喜欢写一些以 MC 和自然为主题的冒险小说片段。"},{"title":"CATEGORY","date":"2025-01-27T10:09:42.000Z","updated":"2025-01-27T04:53:38.741Z","comments":true,"path":"categories/index.html","permalink":"https://allen2010.github.io/categories/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2022-06-08T10:10:12.000Z","updated":"2025-01-26T23:44:45.801Z","comments":true,"path":"tags/index.html","permalink":"https://allen2010.github.io/tags/index.html","excerpt":"","text":""},{"title":"FRIENDS","date":"2025-01-27T04:21:54.497Z","updated":"2025-01-27T04:21:54.497Z","comments":true,"path":"friends/index.html","permalink":"https://allen2010.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Minecraft:Origin","slug":"Minecraft Origin","date":"2025-02-15T16:00:00.000Z","updated":"2025-02-16T01:44:28.026Z","comments":true,"path":"2025/02/16/Minecraft Origin/","permalink":"https://allen2010.github.io/2025/02/16/Minecraft%20Origin/","excerpt":"","text":"The History我是 Lgy，一位 Minecraft 历史搜寻者。我们都知道，在 Minecraft 世界中，处处都有着意想不到的谜团。于是我叫上了我的朋友，打算追溯这个世界的历史，探索 Minecraft 起源的秘密。在这一段时间内，我们四处游历、探索遗迹、狩猎亡灵，并记下了数不清的笔记。 笔记1 烈焰人，生活在下界维度，似乎在守护着什么。死后会掉落烈焰棒。 烈焰棒、末影珍珠、末影之眼，这来自于三个维度的物品似乎有着千丝万缕的联系。 为何猪灵幻化成的僵尸猪灵会在下界出现？ 远古之城和深暗之域会不会是另一个维度在这个世界遗留的痕迹？ 亡灵生物似乎……本不属于下界。…… 然而看着这些似乎杂乱无章的笔记又能拼凑出什么呢？终于，经过数个日夜的艰苦推理，一张完整的真相似乎浮出了水面。可正当我打算将这一切告诉朋友们时，意外发生了。 笔记2 那时我正在远古之城考察，正顺着幽匿脉络探索时，我不慎摔落地面。“咣……”监守者悄然出现，我不断后退，确碰到了一块坚硬的东西。监守者被吸引了过来，他似乎被激怒了。我慌忙逃走，没想到一束音波正在朝我袭来。我眼见无路可逃，干脆转头超音波出现的方向扑去——监守者的胸骨。霎时间，胸骨再次张开，眼见又一次音波即将袭来，一股强大的涡流把我吸进了监守者那个黑洞一般的胸腔……监守者消失了。我也消失了。我似乎死了。但我能听见……那是绵羊的声音？","categories":[{"name":"Essay","slug":"Essay","permalink":"https://allen2010.github.io/categories/Essay/"}],"tags":[{"name":"novel","slug":"novel","permalink":"https://allen2010.github.io/tags/novel/"}]},{"title":"Segment Tree 线段树笔记","slug":"SegT","date":"2025-01-26T16:00:00.000Z","updated":"2025-01-27T07:48:54.857Z","comments":true,"path":"2025/01/27/SegT/","permalink":"https://allen2010.github.io/2025/01/27/SegT/","excerpt":"","text":"算法描述 线段树是一种能够处理区间修改和区间查询的数据结构。 顾名思义，线段树就是一种存储着线段数据的树形结构。它的每个节点都表示一个线段区间，每个节点的孩子节点存储的就是该区间的左半段和右半段。每个线段区间都存储着一个值，一般是区间和，也有可能是区间最大&#x2F;最小值。 算法实现线段树使用数组实现，根节点编号为 $1$ 表示区间 $1$ 到 $n$，左子节点是 $i \\times 2$，右子节点是 $i \\times 2 + 1$. 12ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125; 初始化从根节点开始，不断的分割区间直到该区间只剩单个数，然后开始向上汇总。传入两个变量 l 和 r， 表示当前节点表示的线段。 1234567891011121314void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125; 区间查询从根节点开始，如果当前的线段不被查询的区间完全包含就一直分两段尝试，直到它被完全包含了，返回该线段的值然后继续递归其他的。 1234567891011121314ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125; 区间修改如果每次修改都从上到下全改一遍，复杂度得 $\\mathcal{O}(n)$ ，太浪费时间了，完全体现不出线段树的优势所在。因此引入懒标记（Lazy Tag）。和查询一样，当线段被区间完全覆盖时，对应的节点自己更新，但它的孩子们不更新。这时给他安上一个懒标记，表示它的子节点需要更新的大小。当区间没有完全覆盖，需要拆分的时候，将当前变量的标记拆掉，传给子节点，这样才不会错算。 12345678910111213141516void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125; 复杂度估算由于线段树原理是每个区间分两段，再将两端区间分别分段以此类推，又有 $n$ 个元素，因此线段树的高度是 $\\log n$ 的。而区间修改和查询最坏都要遍历一遍每一层，因此修改和查询的复杂度都是 $\\mathcal{O}\\log n$ 的，足以应付大部分题目。 总代码题目：洛谷 P3372【模板】线段树 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const ll MAXN = 1e5 + 5;ll sum[4 * MAXN], a[MAXN], tag[4 * MAXN];ll lc(ll p)&#123;return p &lt;&lt; 1;&#125;ll rc(ll p)&#123;return p &lt;&lt; 1 | 1;&#125;void pushUp(ll p)&#123; sum[p] = sum[lc(p)] + sum[rc(p)];&#125;void build(ll p, ll l, ll r)&#123; if(l == r)&#123; sum[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lc(p), l, mid); build(rc(p), mid + 1, r); pushUp(p); &#125;void moveTag(ll p, ll l, ll r, ll t)&#123; sum[p] += t * (r - l + 1); tag[p] += t;&#125;void pushDown(ll p, ll l, ll r)&#123; ll mid = (l + r) &gt;&gt; 1; moveTag(lc(p), l, mid, tag[p]); moveTag(rc(p), mid + 1, r, tag[p]); tag[p] = 0;&#125;void Update(ll p, ll l, ll r, ll ql, ll qr, ll d)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; sum[p] += d * (r - l + 1); tag[p] += d; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid)&#123; Update(lc(p), l, mid, ql, qr, d); &#125; if(qr &gt; mid)&#123; Update(rc(p), mid + 1, r, ql, qr, d); &#125; pushUp(p);&#125;ll Query(ll p, ll l, ll r, ll ql, ll qr)&#123; if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123; return sum[p]; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1, ans = 0; if(ql &lt;= mid)&#123; ans += Query(lc(p), l, mid, ql, qr); &#125; if(qr &gt; mid)&#123; ans += Query(rc(p), mid + 1, r, ql, qr); &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(ll i = 1; i &lt;= n; i ++)&#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); while(m --)&#123; ll o, x, y, k; cin &gt;&gt; o; if(o == 1)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; Update(1, 1, n, x, y, k); &#125;else&#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; Query(1, 1, n, x, y) &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"}]},{"title":"First BLog","slug":"First-Blog","date":"2025-01-25T16:00:00.000Z","updated":"2025-01-27T04:59:45.344Z","comments":true,"path":"2025/01/26/First-Blog/","permalink":"https://allen2010.github.io/2025/01/26/First-Blog/","excerpt":"","text":"First Blog这是我的第一篇博客，以此纪念经历一周方才搭建成功的博客。","categories":[{"name":"Unknown","slug":"Unknown","permalink":"https://allen2010.github.io/categories/Unknown/"}],"tags":[{"name":"memento","slug":"memento","permalink":"https://allen2010.github.io/tags/memento/"}]}],"categories":[{"name":"Essay","slug":"Essay","permalink":"https://allen2010.github.io/categories/Essay/"},{"name":"Note","slug":"Note","permalink":"https://allen2010.github.io/categories/Note/"},{"name":"Unknown","slug":"Unknown","permalink":"https://allen2010.github.io/categories/Unknown/"}],"tags":[{"name":"novel","slug":"novel","permalink":"https://allen2010.github.io/tags/novel/"},{"name":"algorithm","slug":"algorithm","permalink":"https://allen2010.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://allen2010.github.io/tags/data-structure/"},{"name":"memento","slug":"memento","permalink":"https://allen2010.github.io/tags/memento/"}]}